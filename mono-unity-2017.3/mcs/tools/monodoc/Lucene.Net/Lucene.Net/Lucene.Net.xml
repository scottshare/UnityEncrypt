<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Lucene.Net</name>
    </assembly>
    <members>
        <member name="T:Lucene.Net.Analysis.DE.GermanAnalyzer">
            <summary> Analyzer for German language. Supports an external list of stopwords (words that
            will not be indexed at all) and an external list of exclusions (word that will
            not be stemmed, but indexed).
            A default set of stopwords is used unless an alternative list is specified, the
            exclusion list is empty by default.
            
            </summary>
            <author>  Gerhard Schwarz
            </author>
            <version>  $Id: GermanAnalyzer.java,v 1.16 2004/05/30 20:24:20 otis Exp $
            </version>
        </member>
        <member name="T:Lucene.Net.Analysis.Analyzer">
            <summary>An Analyzer builds TokenStreams, which analyze text.  It thus represents a
            policy for extracting index terms from text.
            <p>
            Typical implementations first build a Tokenizer, which breaks the stream of
            characters from the Reader into raw Tokens.  One or more TokenFilters may
            then be applied to the output of the Tokenizer.
            </p>
            <p>
            WARNING: You must override one of the methods defined by this class in your
            subclass or the Analyzer will enter an infinite loop.
            </p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.TokenStream(System.String,System.IO.TextReader)">
            <summary>Creates a TokenStream which tokenizes all the text in the provided
            Reader.  Default implementation forwards to tokenStream(Reader) for 
            compatibility with older version.  Override to allow Analyzer to choose 
            strategy based on document and/or Field.  Must be able to handle null
            Field name for backward compatibility. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.TokenStream(System.IO.TextReader)">
            <summary>Creates a TokenStream which tokenizes all the text in the provided
            Reader.  Provided for backward compatibility only.
            </summary>
            <deprecated> use TokenStream(String, Reader) instead.
            </deprecated>
            <seealso cref="!:Reader)">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Analysis.DE.GermanAnalyzer.GERMAN_STOP_WORDS">
            <summary> List of typical german stopwords.</summary>
        </member>
        <member name="F:Lucene.Net.Analysis.DE.GermanAnalyzer.stopSet">
            <summary> Contains the stopwords used with the StopFilter.</summary>
        </member>
        <member name="F:Lucene.Net.Analysis.DE.GermanAnalyzer.exclusionSet">
            <summary> Contains words that should be indexed but not stemmed.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.GermanAnalyzer.#ctor">
            <summary> Builds an analyzer.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.GermanAnalyzer.#ctor(System.String[])">
            <summary> Builds an analyzer with the given stop words.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.GermanAnalyzer.#ctor(System.Collections.Hashtable)">
            <summary> Builds an analyzer with the given stop words.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.GermanAnalyzer.#ctor(System.IO.FileInfo)">
            <summary> Builds an analyzer with the given stop words.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.GermanAnalyzer.SetStemExclusionTable(System.String[])">
            <summary> Builds an exclusionlist from an array of Strings.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.GermanAnalyzer.SetStemExclusionTable(System.Collections.Hashtable)">
            <summary> Builds an exclusionlist from a Hashtable.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.GermanAnalyzer.SetStemExclusionTable(System.IO.FileInfo)">
            <summary> Builds an exclusionlist from the words contained in the given file.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.GermanAnalyzer.TokenStream(System.String,System.IO.TextReader)">
            <summary> Creates a TokenStream which tokenizes all the text in the provided Reader.
            
            </summary>
            <returns> A TokenStream build from a StandardTokenizer filtered with
            StandardFilter, LowerCaseFilter, StopFilter, GermanStemFilter
            </returns>
        </member>
        <member name="T:Lucene.Net.Analysis.DE.GermanStemFilter">
            <summary> A filter that stems German words. It supports a table of words that should
            not be stemmed at all. The stemmer used can be changed at runtime after the
            filter object is created (as long as it is a GermanStemmer).
            
            </summary>
            <author>     Gerhard Schwarz
            </author>
            <version>    $Id: GermanStemFilter.java,v 1.8 2004/03/30 15:54:48 otis Exp $
            </version>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.TokenFilter" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.TokenStream" -->
        <member name="M:Lucene.Net.Analysis.TokenStream.Next">
            <summary>Returns the next token in the stream, or null at EOS. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStream.Close">
            <summary>Releases resources associated with this stream. </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.TokenFilter.input">
            <summary>The source of tokens for this filter. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenFilter.#ctor">
            <summary>Call TokenFilter(TokenStream) instead.</summary>
            <deprecated> 
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenFilter.#ctor(Lucene.Net.Analysis.TokenStream)">
            <summary>Construct a token stream filtering the given input. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenFilter.Close">
            <summary>Close the input TokenStream. </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.DE.GermanStemFilter.token">
            <summary> The actual token in the input stream.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.GermanStemFilter.#ctor(Lucene.Net.Analysis.TokenStream,System.Collections.Hashtable)">
            <summary> Builds a GermanStemFilter that uses an exclusiontable.</summary>
            <deprecated> Use {@link #GermanStemFilter(Lucene.Net.Analysis.TokenStream, java.util.Set)} instead.
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.GermanStemFilter.Next">
            <returns>  Returns the next token in the stream, or null at EOS
            </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.GermanStemFilter.SetStemmer(Lucene.Net.Analysis.DE.GermanStemmer)">
            <summary> Set a alternative/custom GermanStemmer for this filter.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.GermanStemFilter.SetExclusionTable(System.Collections.Hashtable)">
            <summary> Set an alternative exclusion list for this filter.</summary>
            <deprecated> Use {@link #SetExclusionSet(java.util.Set)} instead.
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.GermanStemFilter.SetExclusionSet(System.Collections.Hashtable)">
            <summary> Set an alternative exclusion list for this filter.</summary>
        </member>
        <member name="T:Lucene.Net.Analysis.DE.GermanStemmer">
            <summary> A stemmer for German words. The algorithm is based on the report
            "A Fast and Simple Stemming Algorithm for German Words" by JÃ¶rg
            Caumanns (joerg.caumanns@isst.fhg.de).
            
            </summary>
            <author>     Gerhard Schwarz
            </author>
            <version>    $Id: GermanStemmer.java,v 1.11 2004/05/30 20:24:20 otis Exp $
            </version>
        </member>
        <member name="F:Lucene.Net.Analysis.DE.GermanStemmer.sb">
            <summary> Buffer for the terms while stemming them.</summary>
        </member>
        <member name="F:Lucene.Net.Analysis.DE.GermanStemmer.substCount">
            <summary> Amount of characters that are removed with <tt>substitute()</tt> while stemming.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.GermanStemmer.Stem(System.String)">
            <summary> Stemms the given term to an unique <tt>discriminator</tt>.
            
            </summary>
            <param name="term"> The term that should be stemmed.
            </param>
            <returns>      Discriminator for <tt>term</tt>
            </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.GermanStemmer.IsStemmable(System.String)">
            <summary> Checks if a term could be stemmed.
            
            </summary>
            <returns>  true if, and only if, the given term consists in letters.
            </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.GermanStemmer.Strip(System.Text.StringBuilder)">
            <summary> suffix stripping (stemming) on the current term. The stripping is reduced
            to the seven "base" suffixes "e", "s", "n", "t", "em", "er" and * "nd",
            from which all regular suffixes are build of. The simplification causes
            some overstemming, and way more irregular stems, but still provides unique.
            discriminators in the most of those cases.
            The algorithm is context free, except of the length restrictions.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.GermanStemmer.Optimize(System.Text.StringBuilder)">
            <summary> Does some optimizations on the term. This optimisations are
            contextual.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.GermanStemmer.RemoveParticleDenotion(System.Text.StringBuilder)">
            <summary> Removes a particle denotion ("ge") from a term.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.DE.GermanStemmer.Substitute(System.Text.StringBuilder)" -->
        <member name="M:Lucene.Net.Analysis.DE.GermanStemmer.Resubstitute(System.Text.StringBuilder)">
            <summary> Undoes the changes made by substitute(). That are character pairs and
            character combinations. Umlauts will remain as their corresponding vowel,
            as "Ã" remains as "ss".
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.DE.WordlistLoader">
            <summary> Loader for text files that represent a list of stopwords.
            
            </summary>
            <author>  Gerhard Schwarz
            </author>
            <version>  $Id: WordlistLoader.java,v 1.10 2004/03/30 15:54:48 otis Exp $
            
            </version>
            <todo>  this is not specific to German, it should be moved up </todo>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.WordlistLoader.GetWordSet(System.IO.FileInfo)">
            <summary> Loads a text file and adds every line as an entry to a HashSet (omitting
            leading and trailing whitespace). Every line of the file should contain only 
            one word. The words need to be in lowercase if you make use of an
            Analyzer which uses LowerCaseFilter (like GermanAnalyzer).
            
            </summary>
            <param name="wordfile">File containing the wordlist
            </param>
            <returns> A HashSet with the file's words
            </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.WordlistLoader.GetWordtable(System.String,System.String)">
            <param name="path">     Path to the wordlist
            </param>
            <param name="wordfile"> Name of the wordlist
            
            </param>
            <deprecated> Use {@link #GetWordSet(File)} getWordSet(File)} instead
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.WordlistLoader.GetWordtable(System.String)">
            <param name="wordfile"> Complete path to the wordlist
            
            </param>
            <deprecated> Use {@link #GetWordSet(File)} getWordSet(File)} instead
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.WordlistLoader.GetWordtable(System.IO.FileInfo)">
            <param name="wordfile"> File object that points to the wordlist
            
            </param>
            <deprecated> Use {@link #GetWordSet(File)} getWordSet(File)} instead
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.WordlistLoader.MakeWordTable(System.Collections.Hashtable)">
            <summary> Builds a wordlist table, using words as both keys and values
            for backward compatibility.
            
            </summary>
            <param name="wordSet">  stopword set
            </param>
        </member>
        <member name="T:Lucene.Net.Analysis.RU.RussianAnalyzer">
            <summary> Analyzer for Russian language. Supports an external list of stopwords (words that
            will not be indexed at all).
            A default set of stopwords is used unless an alternative list is specified.
            
            </summary>
            <author>   Boris Okner, b.okner@rogers.com
            </author>
            <version>  $Id: RussianAnalyzer.java,v 1.7 2004/03/29 22:48:01 cutting Exp $
            </version>
        </member>
        <member name="F:Lucene.Net.Analysis.RU.RussianAnalyzer.RUSSIAN_STOP_WORDS">
            <summary> List of typical Russian stopwords.</summary>
        </member>
        <member name="F:Lucene.Net.Analysis.RU.RussianAnalyzer.stopSet">
            <summary> Contains the stopwords used with the StopFilter.</summary>
        </member>
        <member name="F:Lucene.Net.Analysis.RU.RussianAnalyzer.charset">
            <summary> Charset for Russian letters.
            Represents encoding for 32 lowercase Russian letters.
            Predefined charsets can be taken from RussianCharSets class
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianAnalyzer.#ctor(System.Char[])">
            <summary> Builds an analyzer.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianAnalyzer.#ctor(System.Char[],System.String[])">
            <summary> Builds an analyzer with the given stop words.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianAnalyzer.#ctor(System.Char[],System.Collections.Hashtable)">
            <summary> Builds an analyzer with the given stop words.</summary>
            <todo>  create a Set version of this ctor </todo>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianAnalyzer.TokenStream(System.String,System.IO.TextReader)">
            <summary> Creates a TokenStream which tokenizes all the text in the provided Reader.
            
            </summary>
            <returns>  A TokenStream build from a RussianLetterTokenizer filtered with
            RussianLowerCaseFilter, StopFilter, and RussianStemFilter
            </returns>
        </member>
        <member name="T:Lucene.Net.Analysis.RU.RussianCharsets">
            <summary> RussianCharsets class contains encodings schemes (charsets) and toLowerCase() method implementation
            for russian characters in Unicode, KOI8 and CP1252.
            Each encoding scheme contains lowercase (positions 0-31) and uppercase (position 32-63) characters.
            One should be able to add other encoding schemes (like ISO-8859-5 or customized) by adding a new charset
            and adding logic to toLowerCase() method for that charset.
            
            </summary>
            <author>   Boris Okner, b.okner@rogers.com
            </author>
            <version>  $Id: RussianCharsets.java,v 1.3 2004/03/29 22:48:01 cutting Exp $
            </version>
        </member>
        <member name="T:Lucene.Net.Analysis.RU.RussianLetterTokenizer">
            <summary> A RussianLetterTokenizer is a tokenizer that extends LetterTokenizer by additionally looking up letters
            in a given "russian charset". The problem with LeterTokenizer is that it uses Character.isLetter() method,
            which doesn't know how to detect letters in encodings like CP1252 and KOI8
            (well-known problems with 0xD7 and 0xF7 chars)
            
            </summary>
            <author>   Boris Okner, b.okner@rogers.com
            </author>
            <version>  $Id: RussianLetterTokenizer.java,v 1.3 2004/03/29 22:48:01 cutting Exp $
            </version>
        </member>
        <member name="T:Lucene.Net.Analysis.CharTokenizer">
            <summary>An abstract base class for simple, character-oriented tokenizers.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.Tokenizer" -->
        <member name="F:Lucene.Net.Analysis.Tokenizer.input">
            <summary>The text source for this Tokenizer. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenizer.#ctor">
            <summary>Construct a tokenizer with null input. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenizer.#ctor(System.IO.TextReader)">
            <summary>Construct a token stream processing the given input. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenizer.Close">
            <summary>By default, closes the input Reader. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CharTokenizer.IsTokenChar(System.Char)">
            <summary>Returns true iff a character should be included in a token.  This
            tokenizer generates as tokens adjacent sequences of characters which
            satisfy this predicate.  Characters for which this is false are used to
            define token boundaries and are not included in tokens. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CharTokenizer.Normalize(System.Char)">
            <summary>Called on each token character to normalize it before it is added to the
            token.  The default implementation does nothing.  Subclasses may use this
            to, e.g., lowercase tokens. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CharTokenizer.Next">
            <summary>Returns the next token in the stream, or null at EOS. </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.RU.RussianLetterTokenizer.charset">
            <summary>Construct a new LetterTokenizer. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianLetterTokenizer.IsTokenChar(System.Char)">
            <summary> Collects only characters which satisfy
            {@link Character#isLetter(char)}.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.RU.RussianLowerCaseFilter">
            <summary> Normalizes token text to lower case, analyzing given ("russian") charset.
            
            </summary>
            <author>   Boris Okner, b.okner@rogers.com
            </author>
            <version>  $Id: RussianLowerCaseFilter.java,v 1.4 2004/03/29 22:48:01 cutting Exp $
            </version>
        </member>
        <member name="T:Lucene.Net.Analysis.RU.RussianStemFilter">
            <summary> A filter that stems Russian words. The implementation was inspired by GermanStemFilter.
            The input should be filtered by RussianLowerCaseFilter before passing it to RussianStemFilter ,
            because RussianStemFilter only works  with lowercase part of any "russian" charset.
            
            </summary>
            <author>     Boris Okner, b.okner@rogers.com
            </author>
            <version>    $Id: RussianStemFilter.java,v 1.5 2004/03/29 22:48:01 cutting Exp $
            </version>
        </member>
        <member name="F:Lucene.Net.Analysis.RU.RussianStemFilter.token">
            <summary> The actual token in the input stream.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianStemFilter.Next">
            <returns>  Returns the next token in the stream, or null at EOS
            </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianStemFilter.SetStemmer(Lucene.Net.Analysis.RU.RussianStemmer)">
            <summary> Set a alternative/custom RussianStemmer for this filter.</summary>
        </member>
        <member name="T:Lucene.Net.Analysis.RU.RussianStemmer">
            <summary> Russian stemming algorithm implementation (see http://snowball.sourceforge.net for detailed description).
            
            </summary>
            <author>   Boris Okner, b.okner@rogers.com
            </author>
            <version>  $Id: RussianStemmer.java,v 1.5 2004/03/29 22:48:01 cutting Exp $
            </version>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianStemmer.#ctor">
            <summary> RussianStemmer constructor comment.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianStemmer.#ctor(System.Char[])">
            <summary> RussianStemmer constructor comment.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianStemmer.Adjectival(System.Text.StringBuilder)">
            <summary> Adjectival ending is an adjective ending,
            optionally preceded by participle ending.
            Creation date: (17/03/2002 12:14:58 AM)
            </summary>
            <param name="stemmingZone">java.lang.StringBuffer
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianStemmer.Derivational(System.Text.StringBuilder)">
            <summary> Derivational endings
            Creation date: (17/03/2002 12:14:58 AM)
            </summary>
            <param name="stemmingZone">java.lang.StringBuffer
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianStemmer.FindEnding(System.Text.StringBuilder,System.Int32,System.Char[][])">
            <summary> Finds ending among given ending class and returns the length of ending found(0, if not found).
            Creation date: (17/03/2002 8:18:34 PM)
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianStemmer.FindAndRemoveEnding(System.Text.StringBuilder,System.Char[][])">
            <summary> Finds the ending among the given class of endings and removes it from stemming zone.
            Creation date: (17/03/2002 8:18:34 PM)
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianStemmer.FindAndRemoveEnding(System.Text.StringBuilder,System.Char[][],System.Char[][])">
            <summary> Finds the ending among the given class of endings, then checks if this ending was
            preceded by any of given predessors, and if so, removes it from stemming zone.
            Creation date: (17/03/2002 8:18:34 PM)
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianStemmer.MarkPositions(System.String)">
            <summary> Marks positions of RV, R1 and R2 in a given word.
            Creation date: (16/03/2002 3:40:11 PM)
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianStemmer.IsVowel(System.Char)">
            <summary> Checks if character is a vowel..
            Creation date: (16/03/2002 10:47:03 PM)
            </summary>
            <returns> boolean
            </returns>
            <param name="letter">char
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianStemmer.Noun(System.Text.StringBuilder)">
            <summary> Noun endings.
            Creation date: (17/03/2002 12:14:58 AM)
            </summary>
            <param name="stemmingZone">java.lang.StringBuffer
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianStemmer.PerfectiveGerund(System.Text.StringBuilder)">
            <summary> Perfective gerund endings.
            Creation date: (17/03/2002 12:14:58 AM)
            </summary>
            <param name="stemmingZone">java.lang.StringBuffer
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianStemmer.Reflexive(System.Text.StringBuilder)">
            <summary> Reflexive endings.
            Creation date: (17/03/2002 12:14:58 AM)
            </summary>
            <param name="stemmingZone">java.lang.StringBuffer
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianStemmer.RemoveI(System.Text.StringBuilder)">
            <summary> Insert the method's description here.
            Creation date: (17/03/2002 12:14:58 AM)
            </summary>
            <param name="stemmingZone">java.lang.StringBuffer
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianStemmer.RemoveSoft(System.Text.StringBuilder)">
            <summary> Insert the method's description here.
            Creation date: (17/03/2002 12:14:58 AM)
            </summary>
            <param name="stemmingZone">java.lang.StringBuffer
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianStemmer.SetCharset(System.Char[])">
            <summary> Insert the method's description here.
            Creation date: (16/03/2002 10:58:42 PM)
            </summary>
            <param name="newCharset">char[]
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianStemmer.SetEndings">
            <summary> Set ending definition as in Russian stemming algorithm.
            Creation date: (16/03/2002 11:16:36 PM)
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianStemmer.Stem(System.String)">
            <summary> Finds the stem for given Russian word.
            Creation date: (16/03/2002 3:36:48 PM)
            </summary>
            <returns> java.lang.String
            </returns>
            <param name="input">java.lang.String
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianStemmer.Superlative(System.Text.StringBuilder)">
            <summary> Superlative endings.
            Creation date: (17/03/2002 12:14:58 AM)
            </summary>
            <param name="stemmingZone">java.lang.StringBuffer
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianStemmer.UndoubleN(System.Text.StringBuilder)">
            <summary> Undoubles N.
            Creation date: (17/03/2002 12:14:58 AM)
            </summary>
            <param name="stemmingZone">java.lang.StringBuffer
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianStemmer.Verb(System.Text.StringBuilder)">
            <summary> Verb endings.
            Creation date: (17/03/2002 12:14:58 AM)
            </summary>
            <param name="stemmingZone">java.lang.StringBuffer
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.RU.RussianStemmer.Stem(System.String,System.Char[])">
            <summary> Static method for stemming with different charsets</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.CharStream.ReadChar">
            <summary> Returns the next character from the selected input.  The method
            of selecting the input is the responsibility of the class
            implementing this interface.  Can throw any java.io.IOException.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.CharStream.GetColumn">
            <summary> Returns the column position of the character last read.</summary>
            <deprecated> 
            </deprecated>
            <seealso cref="!:#getEndColumn">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.CharStream.GetLine">
            <summary> Returns the line number of the character last read.</summary>
            <deprecated> 
            </deprecated>
            <seealso cref="!:#getEndLine">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.CharStream.GetEndColumn">
            <summary> Returns the column number of the last character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.CharStream.GetEndLine">
            <summary> Returns the line number of the last character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.CharStream.GetBeginColumn">
            <summary> Returns the column number of the first character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.CharStream.GetBeginLine">
            <summary> Returns the line number of the first character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.CharStream.Backup(System.Int32)">
            <summary> Backs up the input stream by amount steps. Lexer calls this method if it
            had already read some characters, but could not use them to match a
            (longer) token. So, they will be used again as the prefix of the next
            token and it is the implemetation's responsibility to do this right.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.CharStream.BeginToken">
            <summary> Returns the next character that marks the beginning of the next token.
            All characters must remain in the buffer between two successive calls
            to this method to implement backup correctly.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.CharStream.GetImage">
            <summary> Returns a string made up of characters from the marked token beginning 
            to the current buffer position. Implementations have the choice of returning
            anything that they want to. For example, for efficiency, one might decide
            to just return null, which is a valid implementation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.CharStream.GetSuffix(System.Int32)">
            <summary> Returns an array of characters that make up the suffix of length 'len' for
            the currently matched token. This is used to build up the matched string
            for use in actions in the case of MORE. A simple and inefficient
            implementation of this is as follows :
            
            {
            String t = GetImage();
            return t.substring(t.length() - len, t.length()).toCharArray();
            }
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.CharStream.Done">
            <summary> The lexer calls this function to indicate that it is done with the stream
            and hence implementations can free any resources held by this class.
            Again, the body of this function can be just empty and it will not
            affect the lexer's operation.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.Standard.FastCharStream" -->
        <member name="M:Lucene.Net.Analysis.Standard.FastCharStream.#ctor(System.IO.TextReader)">
            <summary>Constructs from a Reader. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Standard.ParseException">
            <summary> This exception is thrown when parse errors are encountered.
            You can explicitly create objects of this exception type by
            calling the method generateParseException in the generated
            parser.
            
            You can modify this class to customize your error reporting
            mechanisms so long as you retain the public fields.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.ParseException.#ctor(Lucene.Net.Analysis.Standard.Token,System.Int32[][],System.String[])">
            <summary> This constructor is used by the method "generateParseException"
            in the generated parser.  Calling this constructor generates
            a new object of this type with the fields "currentToken",
            "expectedTokenSequences", and "tokenImage" set.  The boolean
            flag "specialConstructor" is also set to true to indicate that
            this constructor was used to create this object.
            This constructor calls its super class with the empty string
            to force the "toString" method of parent class "Throwable" to
            print the error message in the form:
            ParseException: &lt;result of getMessage&gt;
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.ParseException.#ctor">
            <summary> The following constructors are for use by you for whatever
            purpose you can think of.  Constructing the exception in this
            manner makes the exception behave in the normal way - i.e., as
            documented in the class "Throwable".  The fields "errorToken",
            "expectedTokenSequences", and "tokenImage" do not contain
            relevant information.  The JavaCC generated code does not use
            these constructors.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.ParseException.specialConstructor">
            <summary> This variable determines which constructor was used to create
            this object and thereby affects the semantics of the
            "getMessage" method (see below).
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.ParseException.currentToken">
            <summary> This is the last token that has been consumed successfully.  If
            this object has been created due to a parse error, the token
            followng this token will (therefore) be the first error token.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.ParseException.expectedTokenSequences">
            <summary> Each entry in this array is an array of integers.  Each array
            of integers represents a sequence of tokens (by their ordinal
            values) that is expected at this point of the parse.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.ParseException.tokenImage">
            <summary> This is a reference to the "tokenImage" array of the generated
            parser within which the parse error occurred.  This array is
            defined in the generated ...Constants interface.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.ParseException.eol">
            <summary> The end of line string for this machine.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.ParseException.Add_escapes(System.String)">
            <summary> Used to convert raw characters to their escaped version
            when these raw version cannot be used as part of an ASCII
            string literal.
            </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.Standard.ParseException.Message">
            <summary> This method has the standard behavior when this object has been
            created using the standard constructors.  Otherwise, it uses
            "currentToken" and "expectedTokenSequences" to generate a parse
            error message and returns it.  If this object has been created
            due to a parse error, and you do not catch it (it gets thrown
            from the parser), then this method is called during the printing
            of the final stack trace, and hence the correct error message
            gets displayed.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Standard.StandardAnalyzer">
            <summary> Filters {@link StandardTokenizer} with {@link StandardFilter}, {@link
            LowerCaseFilter} and {@link StopFilter}.
            
            </summary>
            <version>  $Id: StandardAnalyzer.java,v 1.8 2004/03/29 22:48:01 cutting Exp $
            </version>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardAnalyzer.STOP_WORDS">
            <summary>An array containing some common English words that are usually not
            useful for searching. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.#ctor">
            <summary>Builds an analyzer. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.#ctor(System.String[])">
            <summary>Builds an analyzer with the given stop words. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.TokenStream(System.String,System.IO.TextReader)">
            <summary>Constructs a {@link StandardTokenizer} filtered by a {@link
            StandardFilter}, a {@link LowerCaseFilter} and a {@link StopFilter}. 
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Standard.StandardFilter">
            <summary>Normalizes tokens extracted with {@link StandardTokenizer}. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardFilter.#ctor(Lucene.Net.Analysis.TokenStream)">
            <summary>Construct filtering <i>in</i>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Standard.StandardFilter.Next" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.Standard.StandardTokenizer" -->
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizer.#ctor(System.IO.TextReader)">
            <summary>Constructs a tokenizer for this Reader. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Standard.StandardTokenizer.Next" -->
        <member name="T:Lucene.Net.Analysis.Standard.Token">
            <summary> Describes the input token stream.</summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.Token.kind">
            <summary> An integer that describes the kind of this token.  This numbering
            system is determined by JavaCCParser, and a table of these numbers is
            stored in the file ...Constants.java.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.Token.beginLine">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.Token.beginColumn">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.Token.endLine">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.Token.endColumn">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.Token.image">
            <summary> The string image of the token.</summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.Token.next">
            <summary> A reference to the next regular (non-special) token from the input
            stream.  If this is the last token from the input stream, or if the
            token manager has not read tokens beyond this one, this Field is
            set to null.  This is true only if this token is also a regular
            token.  Otherwise, see below for a description of the contents of
            this Field.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.Token.specialToken">
            <summary> This Field is used to access special tokens that occur prior to this
            token, but after the immediately preceding regular (non-special) token.
            If there are no such special tokens, this Field is set to null.
            When there are more than one such special token, this Field refers
            to the last of these special tokens, which in turn refers to the next
            previous special token through its specialToken Field, and so on
            until the first special token (whose specialToken Field is null).
            The next fields of special tokens refer to other special tokens that
            immediately follow it (without an intervening regular token).  If there
            is no such token, this Field is null.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.Token.ToString">
            <summary> Returns the image.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.Token.NewToken(System.Int32)">
            <summary> Returns a new Token object, by default. However, if you want, you
            can create and return subclass objects based on the value of ofKind.
            Simply add the cases to the switch for all those special cases.
            For example, if you have a subclass of Token called IDToken that
            you want to create if ofKind is ID, simlpy add something like :
            
            case MyParserConstants.ID : return new IDToken();
            
            to the following switch statement. Then you can cast matchedToken
            variable to the appropriate type and use it in your lexical actions.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.TokenMgrError.LEXICAL_ERROR">
            <summary> Lexical error occured.</summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.TokenMgrError.STATIC_LEXER_ERROR">
            <summary> An attempt wass made to create a second instance of a static token manager.</summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.TokenMgrError.INVALID_LEXICAL_STATE">
            <summary> Tried to change to an invalid lexical state.</summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.TokenMgrError.LOOP_DETECTED">
            <summary> Detected (and bailed out of) an infinite loop in the token manager.</summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.TokenMgrError.errorCode">
            <summary> Indicates the reason why the exception is thrown. It will have
            one of the above 4 values.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.TokenMgrError.addEscapes(System.String)">
            <summary> Replaces unprintable characters by their espaced (or unicode escaped)
            equivalents in the given string
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.TokenMgrError.LexicalError(System.Boolean,System.Int32,System.Int32,System.Int32,System.String,System.Char)">
            <summary> Returns a detailed message for the Error when it is thrown by the
            token manager to indicate a lexical error.
            Parameters : 
            EOFSeen     : indicates if EOF caused the lexicl error
            curLexState : lexical state in which this error occured
            errorLine   : line number when the error occured
            errorColumn : column number when the error occured
            errorAfter  : prefix that was seen before this error occured
            curchar     : the offending character
            Note: You can customize the lexical error message by modifying this method.
            </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.Standard.TokenMgrError.Message">
            <summary> You can also modify the body of this method to customize your error messages.
            For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
            of end-users concern, so you can return something like : 
            
            "Internal Error : Please file a bug report .... "
            
            from this method for such cases in the release version of your parser.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.LetterTokenizer">
            <summary>A LetterTokenizer is a tokenizer that divides text at non-letters.  That's
            to say, it defines tokens as maximal strings of adjacent letters, as defined
            by java.lang.Character.isLetter() predicate.
            Note: this does a decent job for most European languages, but does a terrible
            job for some Asian languages, where words are not separated by spaces. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.LetterTokenizer.#ctor(System.IO.TextReader)">
            <summary>Construct a new LetterTokenizer. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.LetterTokenizer.IsTokenChar(System.Char)">
            <summary>Collects only characters which satisfy
            {@link Character#isLetter(char)}.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.LowerCaseFilter">
            <summary> Normalizes token text to lower case.
            
            </summary>
            <version>  $Id: LowerCaseFilter.java,v 1.4 2004/03/29 22:48:00 cutting Exp $
            </version>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.LowerCaseTokenizer" -->
        <member name="M:Lucene.Net.Analysis.LowerCaseTokenizer.#ctor(System.IO.TextReader)">
            <summary>Construct a new LowerCaseTokenizer. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.LowerCaseTokenizer.Normalize(System.Char)">
            <summary>Collects only characters which satisfy
            {@link Character#isLetter(char)}.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.PerFieldAnalyzerWrapper">
            <summary> This analyzer is used to facilitate scenarios where different
            fields require different analysis techniques.  Use {@link #addAnalyzer}
            to add a non-default analyzer on a Field name basis.
            See TestPerFieldAnalyzerWrapper.java for example usage.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PerFieldAnalyzerWrapper.#ctor(Lucene.Net.Analysis.Analyzer)">
            <summary> Constructs with default analyzer.
            
            </summary>
            <param name="defaultAnalyzer">Any fields not specifically
            defined to use a different analyzer will use the one provided here.
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.PerFieldAnalyzerWrapper.AddAnalyzer(System.String,Lucene.Net.Analysis.Analyzer)">
            <summary> Defines an analyzer to use for the specified Field.
            
            </summary>
            <param name="fieldName">Field name requiring a non-default analyzer.
            </param>
            <param name="analyzer">non-default analyzer to use for Field
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.PorterStemFilter" -->
        <member name="M:Lucene.Net.Analysis.PorterStemFilter.Next">
            <summary>Returns the next input Token, after being stemmed </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.PorterStemmer">
            <summary> 
            Stemmer, implementing the Porter Stemming Algorithm
            
            The Stemmer class transforms a word into its root form.  The input
            word can be provided a character at time (by calling add()), or at once
            by calling one of the various stem(something) methods.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Reset">
            <summary> reset() resets the stemmer so it can stem another word.  If you invoke
            the stemmer by calling add(char) and then stem(), you must call reset()
            before starting another word.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Add(System.Char)">
            <summary> Add a character to the word being stemmed.  When you are finished
            adding characters, you can call stem(void) to process the word.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.ToString">
            <summary> After a word has been stemmed, it can be retrieved by toString(),
            or a reference to the internal buffer can be retrieved by getResultBuffer
            and getResultLength (which is generally more efficient.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.GetResultLength">
            <summary> Returns the length of the word resulting from the stemming process.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.GetResultBuffer">
            <summary> Returns a reference to a character buffer containing the results of
            the stemming process.  You also need to consult getResultLength()
            to determine the length of the result.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Stem(System.String)">
            <summary> Stem a word provided as a String.  Returns the result as a String.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Stem(System.Char[])">
            <summary>Stem a word contained in a char[].  Returns true if the stemming process
            resulted in a word different from the input.  You can retrieve the
            result with getResultLength()/getResultBuffer() or toString().
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Stem(System.Char[],System.Int32,System.Int32)">
            <summary>Stem a word contained in a portion of a char[] array.  Returns
            true if the stemming process resulted in a word different from
            the input.  You can retrieve the result with
            getResultLength()/getResultBuffer() or toString().
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Stem(System.Char[],System.Int32)">
            <summary>Stem a word contained in a leading portion of a char[] array.
            Returns true if the stemming process resulted in a word different
            from the input.  You can retrieve the result with
            getResultLength()/getResultBuffer() or toString().
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Stem">
            <summary>Stem the word placed into the Stemmer buffer through calls to add().
            Returns true if the stemming process resulted in a word different
            from the input.  You can retrieve the result with
            getResultLength()/getResultBuffer() or toString().
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Main(System.String[])">
            <summary>Test program for demonstrating the Stemmer.  It reads a file and
            stems each word, writing the result to standard out.
            Usage: Stemmer file-name
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.SimpleAnalyzer">
            <summary>An Analyzer that filters LetterTokenizer with LowerCaseFilter. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.StopAnalyzer">
            <summary>Filters LetterTokenizer with LowerCaseFilter and StopFilter. </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.StopAnalyzer.ENGLISH_STOP_WORDS">
            <summary>An array containing some common English words that are not usually useful
            for searching. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopAnalyzer.#ctor">
            <summary>Builds an analyzer which removes words in ENGLISH_STOP_WORDS. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopAnalyzer.#ctor(System.String[])">
            <summary>Builds an analyzer which removes words in the provided array. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopAnalyzer.TokenStream(System.String,System.IO.TextReader)">
            <summary>Filters LowerCaseTokenizer with StopFilter. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.StopFilter">
            <summary> Removes stop words from a token stream.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopFilter.#ctor(Lucene.Net.Analysis.TokenStream,System.String[])">
            <summary> Constructs a filter which removes words from the input
            TokenStream that are named in the array of words.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopFilter.#ctor(Lucene.Net.Analysis.TokenStream,System.Collections.Hashtable)">
            <summary> Constructs a filter which removes words from the input
            TokenStream that are named in the Hashtable.
            
            </summary>
            <deprecated> Use {@link #StopFilter(TokenStream, Set)} instead
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.StopFilter.MakeStopTable(System.String[])">
            <summary> Builds a Hashtable from an array of stop words,
            appropriate for passing into the StopFilter constructor.
            This permits this table construction to be cached once when
            an Analyzer is constructed.
            
            </summary>
            <deprecated> Use {@link #MakeStopSet(String[])} instead.
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.StopFilter.MakeStopSet(System.String[])">
            <summary> Builds a Set from an array of stop words,
            appropriate for passing into the StopFilter constructor.
            This permits this stopWords construction to be cached once when
            an Analyzer is constructed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopFilter.Next">
            <summary> Returns the next input Token whose termText() is not a stop word.</summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Token">
            <summary>A Token is an occurence of a term from the text of a Field.  It consists of
            a term's text, the start and end offset of the term in the text of the Field,
            and a type string.
            The start and end offsets permit applications to re-associate a token with
            its source text, e.g., to display highlighted query terms in a document
            browser, or to show matching text fragments in a KWIC (KeyWord In Context)
            display, etc.
            The type is an interned string, assigned by a lexical analyzer
            (a.k.a. tokenizer), naming the lexical or syntactic class that the token
            belongs to.  For example an end of sentence marker token might be implemented
            with type "eos".  The default token type is "word".  
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Token.#ctor(System.String,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Token.#ctor(System.String,System.Int32,System.Int32,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Token.SetPositionIncrement(System.Int32)" -->
        <member name="M:Lucene.Net.Analysis.Token.GetPositionIncrement">
            <summary>Returns the position increment of this Token.</summary>
            <seealso cref="!:#setPositionIncrement">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.TermText">
            <summary>Returns the Token's term text. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.StartOffset">
            <summary>Returns this Token's starting offset, the position of the first character
            corresponding to this token in the source text.
            Note that the difference between endOffset() and startOffset() may not be
            equal to termText.length(), as the term text may have been altered by a
            stemmer or some other filter. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.EndOffset">
            <summary>Returns this Token's ending offset, one greater than the position of the
            last character corresponding to this token in the source text. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Type">
            <summary>Returns this Token's lexical type.  Defaults to "word". </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.WhitespaceAnalyzer">
            <summary>An Analyzer that uses WhitespaceTokenizer. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.WhitespaceTokenizer">
            <summary>A WhitespaceTokenizer is a tokenizer that divides text at whitespace.
            Adjacent sequences of non-Whitespace characters form tokens. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.WhitespaceTokenizer.#ctor(System.IO.TextReader)">
            <summary>Construct a new WhitespaceTokenizer. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.WhitespaceTokenizer.IsTokenChar(System.Char)">
            <summary>Collects only characters which do not satisfy
            {@link Character#isWhitespace(char)}.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.DateField" -->
        <member name="M:Lucene.Net.Documents.DateField.DateToString(System.DateTime)">
            <summary> Converts a Date to a string suitable for indexing.</summary>
            <throws>  RuntimeException if the date specified in the </throws>
            <summary> method argument is before 1970
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DateField.TimeToString(System.Int64)">
            <summary> Converts a millisecond time to a string suitable for indexing.</summary>
            <throws>  RuntimeException if the time specified in the </throws>
            <summary> method argument is negative, that is, before 1970
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DateField.StringToTime(System.String)">
            <summary>Converts a string-encoded date into a millisecond time. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DateField.StringToDate(System.String)">
            <summary>Converts a string-encoded date into a Date object. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.Document" -->
        <member name="M:Lucene.Net.Documents.Document.#ctor">
            <summary>Constructs a new document with no fields. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.Document.SetBoost(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.Document.GetBoost" -->
        <member name="M:Lucene.Net.Documents.Document.Add(Lucene.Net.Documents.Field)">
            <summary> <p>Adds a Field to a document.  Several fields may be added with
            the same name.  In this case, if the fields are indexed, their text is
            treated as though appended for the purposes of search.</p>
            <p> Note that add like the removeField(s) methods only makes sense 
            prior to adding a document to an index. These methods cannot
            be used to change the content of an existing index! In order to achieve this,
            a document has to be deleted from an index and a new changed version of that
            document has to be added.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.RemoveField(System.String)">
            <summary> <p>Removes Field with the specified name from the document.
            If multiple fields exist with this name, this method removes the first Field that has been added.
            If there is no Field with the specified name, the document remains unchanged.</p>
            <p> Note that the removeField(s) methods like the add method only make sense 
            prior to adding a document to an index. These methods cannot
            be used to change the content of an existing index! In order to achieve this,
            a document has to be deleted from an index and a new changed version of that
            document has to be added.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.RemoveFields(System.String)">
            <summary> <p>Removes all fields with the given name from the document.
            If there is no Field with the specified name, the document remains unchanged.</p>
            <p> Note that the removeField(s) methods like the add method only make sense 
            prior to adding a document to an index. These methods cannot
            be used to change the content of an existing index! In order to achieve this,
            a document has to be deleted from an index and a new changed version of that
            document has to be added.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetField(System.String)">
            <summary>Returns a Field with the given name if any exist in this document, or
            null.  If multiple fields exists with this name, this method returns the
            first value added.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.Get(System.String)">
            <summary>Returns the string value of the Field with the given name if any exist in
            this document, or null.  If multiple fields exist with this name, this
            method returns the first value added.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.Fields">
            <summary>Returns an Enumeration of all the fields in a document. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetFields(System.String)">
            <summary> Returns an array of {@link Field}s with the given name.
            This method can return <code>null</code>.
            
            </summary>
            <param name="name">the name of the Field
            </param>
            <returns> a <code>Field[]</code> array
            </returns>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetValues(System.String)">
            <summary> Returns an array of values of the Field specified as the method parameter.
            This method can return <code>null</code>.
            
            </summary>
            <param name="name">the name of the Field
            </param>
            <returns> a <code>String[]</code> of Field values
            </returns>
        </member>
        <member name="M:Lucene.Net.Documents.Document.ToString">
            <summary>Prints the fields of a document for human consumption. </summary>
        </member>
        <member name="T:Lucene.Net.Documents.Field">
            <summary>A Field is a section of a Document.  Each Field has two parts, a name and a
            value.  Values may be free text, provided as a String or as a Reader, or they
            may be atomic keywords, which are not further processed.  Such keywords may
            be used to represent dates, urls, etc.  Fields are optionally stored in the
            index, so that they may be returned with hits on the document.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.Field.SetBoost(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.Field.GetBoost" -->
        <member name="M:Lucene.Net.Documents.Field.Keyword(System.String,System.String)">
            <summary>Constructs a String-valued Field that is not tokenized, but is indexed
            and stored.  Useful for non-text fields, e.g. date or url.  
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.UnIndexed(System.String,System.String)">
            <summary>Constructs a String-valued Field that is not tokenized nor indexed,
            but is stored in the index, for return with hits. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.Text(System.String,System.String)">
            <summary>Constructs a String-valued Field that is tokenized and indexed,
            and is stored in the index, for return with hits.  Useful for short text
            fields, like "title" or "subject". Term vector will not be stored for this Field. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.Keyword(System.String,System.DateTime)">
            <summary>Constructs a Date-valued Field that is not tokenized and is indexed,
            and stored in the index, for return with hits. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.Text(System.String,System.String,System.Boolean)">
            <summary>Constructs a String-valued Field that is tokenized and indexed,
            and is stored in the index, for return with hits.  Useful for short text
            fields, like "title" or "subject". 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.UnStored(System.String,System.String)">
            <summary>Constructs a String-valued Field that is tokenized and indexed,
            but that is not stored in the index.  Term vector will not be stored for this Field. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.UnStored(System.String,System.String,System.Boolean)">
            <summary>Constructs a String-valued Field that is tokenized and indexed,
            but that is not stored in the index. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.Text(System.String,System.IO.TextReader)">
            <summary>Constructs a Reader-valued Field that is tokenized and indexed, but is
            not stored in the index verbatim.  Useful for longer text fields, like
            "body". Term vector will not be stored for this Field. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.Text(System.String,System.IO.TextReader,System.Boolean)">
            <summary>Constructs a Reader-valued Field that is tokenized and indexed, but is
            not stored in the index verbatim.  Useful for longer text fields, like
            "body". 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.Name">
            <summary>The name of the Field (e.g., "date", "subject", "title", or "body")
            as an interned string. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.StringValue">
            <summary>The value of the Field as a String, or null.  If null, the Reader value
            is used.  Exactly one of stringValue() and readerValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.ReaderValue">
            <summary>The value of the Field as a Reader, or null.  If null, the String value
            is used.  Exactly one of stringValue() and readerValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Create a Field by specifying all parameters except for <code>storeTermVector</code>,
            which is set to <code>false</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary> </summary>
            <param name="name">The name of the Field
            </param>
            <param name="string">The string to process
            </param>
            <param name="store">true if the Field should store the string
            </param>
            <param name="index">true if the Field should be indexed
            </param>
            <param name="token">true if the Field should be tokenized
            </param>
            <param name="storeTermVector">true if we should store the Term Vector info
            </param>
        </member>
        <member name="M:Lucene.Net.Documents.Field.IsStored">
            <summary>True iff the value of the Field is to be stored in the index for return
            with search hits.  It is an error for this to be true if a Field is
            Reader-valued. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.IsIndexed">
            <summary>True iff the value of the Field is to be indexed, so that it may be
            searched on. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.IsTokenized">
            <summary>True iff the value of the Field should be tokenized as text prior to
            indexing.  Un-tokenized fields are indexed as a single word and may not be
            Reader-valued. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.IsTermVectorStored">
            <summary>True iff the term or terms used to index this Field are stored as a term
            vector, available from {@link IndexReader#GetTermFreqVector(int,String)}.
            These methods do not provide access to the original content of the Field,
            only to terms used to index it. If the original content must be
            preserved, use the <code>stored</code> attribute instead.
            
            </summary>
            <seealso cref="!:String)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Documents.Field.ToString">
            <summary>Prints a Field for human consumption. </summary>
        </member>
        <member name="T:Lucene.Net.Index.CompoundFileReader">
            <summary> Class for accessing a compound stream.
            This class implements a directory, but is limited to only read operations.
            Directory methods that would normally modify data throw an exception.
            
            </summary>
            <author>  Dmitry Serebrennikov
            </author>
            <version>  $Id: CompoundFileReader.java,v 1.7 2004/07/12 14:36:04 otis Exp $
            </version>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.Directory" -->
        <member name="M:Lucene.Net.Store.Directory.List">
            <summary>Returns an array of strings, one for each file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.FileExists(System.String)">
            <summary>Returns true iff a file with the given name exists. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.FileModified(System.String)">
            <summary>Returns the time the named file was last modified. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.TouchFile(System.String)">
            <summary>Set the modified time of an existing file to now. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.DeleteFile(System.String)">
            <summary>Removes an existing file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.RenameFile(System.String,System.String)">
            <summary>Renames an existing file in the directory.
            If a file already exists with the new name, then it is replaced.
            This replacement should be atomic. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.FileLength(System.String)">
            <summary>Returns the length of a file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.CreateFile(System.String)">
            <summary>Creates a new, empty file in the directory with the given name.
            Returns a stream writing this file. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.OpenFile(System.String)">
            <summary>Returns a stream reading an existing file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.MakeLock(System.String)">
            <summary>Construct a {@link Lock}.</summary>
            <param name="name">the name of the lock file
            </param>
        </member>
        <member name="M:Lucene.Net.Store.Directory.Close">
            <summary>Closes the store. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.List">
            <summary>Returns an array of strings, one for each file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.FileExists(System.String)">
            <summary>Returns true iff a file with the given name exists. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.FileModified(System.String)">
            <summary>Returns the time the named file was last modified. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.TouchFile(System.String)">
            <summary>Set the modified time of an existing file to now. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.DeleteFile(System.String)">
            <summary>Removes an existing file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.RenameFile(System.String,System.String)">
            <summary>Renames an existing file in the directory.
            If a file already exists with the new name, then it is replaced.
            This replacement should be atomic. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.FileLength(System.String)">
            <summary>Returns the length of a file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.CreateFile(System.String)">
            <summary>Creates a new, empty file in the directory with the given name.
            Returns a stream writing this file. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.MakeLock(System.String)">
            <summary>Construct a {@link Lock}.</summary>
            <param name="name">the name of the lock file
            </param>
        </member>
        <member name="T:Lucene.Net.Index.CompoundFileReader.CSInputStream">
            <summary>Implementation of an InputStream that reads from a portion of the
            compound file. The visibility is left as "package" *only* because
            this helps with testing since JUnit test cases in a different class
            can then access package fields of this class.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.InputStream">
            <summary>Abstract base class for input from a file in a {@link Directory}.  A
            random-access input stream.  Used for all Lucene index input operations.
            </summary>
            <seealso cref="T:Lucene.Net.Store.Directory">
            </seealso>
            <seealso cref="T:Lucene.Net.Store.OutputStream">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.InputStream.ReadByte">
            <summary>Reads and returns a single byte.</summary>
            <seealso cref="!:OutputStream#WriteByte(byte)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.InputStream.ReadBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Reads a specified number of bytes into an array at the specified offset.</summary>
            <param name="b">the array to read bytes into
            </param>
            <param name="offset">the offset in the array to start storing bytes
            </param>
            <param name="len">the number of bytes to read
            </param>
            <seealso cref="!:OutputStream#WriteBytes(byte[],int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.InputStream.ReadInt">
            <summary>Reads four bytes and returns an int.</summary>
            <seealso cref="!:OutputStream#WriteInt(int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.InputStream.ReadVInt">
            <summary>Reads an int stored in variable-length format.  Reads between one and
            five bytes.  Smaller values take fewer bytes.  Negative numbers are not
            supported.
            </summary>
            <seealso cref="!:OutputStream#WriteVInt(int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.InputStream.ReadLong">
            <summary>Reads eight bytes and returns a long.</summary>
            <seealso cref="!:OutputStream#WriteLong(long)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.InputStream.ReadVLong">
            <summary>Reads a long stored in variable-length format.  Reads between one and
            nine bytes.  Smaller values take fewer bytes.  Negative numbers are not
            supported. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.InputStream.ReadString">
            <summary>Reads a string.</summary>
            <seealso cref="!:OutputStream#WriteString(String)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.InputStream.ReadChars(System.Char[],System.Int32,System.Int32)">
            <summary>Reads UTF-8 encoded characters into an array.</summary>
            <param name="buffer">the array to read characters into
            </param>
            <param name="start">the offset in the array to start storing characters
            </param>
            <param name="length">the number of characters to read
            </param>
            <seealso cref="!:OutputStream#WriteChars(String,int,int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.InputStream.ReadInternal(System.Byte[],System.Int32,System.Int32)">
            <summary>Expert: implements buffer refill.  Reads bytes from the current position
            in the input.
            </summary>
            <param name="b">the array to read bytes into
            </param>
            <param name="offset">the offset in the array to start storing bytes
            </param>
            <param name="length">the number of bytes to read
            </param>
        </member>
        <member name="M:Lucene.Net.Store.InputStream.Close">
            <summary>Closes the stream to futher operations. </summary>
        </member>
        <member name="M:Lucene.Net.Store.InputStream.GetFilePointer">
            <summary>Returns the current position in this file, where the next read will
            occur.
            </summary>
            <seealso cref="!:#Seek(long)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.InputStream.Seek(System.Int64)">
            <summary>Sets current position in this file, where the next read will occur.</summary>
            <seealso cref="!:#GetFilePointer()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.InputStream.SeekInternal(System.Int64)">
            <summary>Expert: implements seek.  Sets current position in this file, where the
            next {@link #ReadInternal(byte[],int,int)} will occur.
            </summary>
            <seealso cref="!:#ReadInternal(byte[],int,int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.InputStream.Length">
            <summary>The number of bytes in the file. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.InputStream.Clone" -->
        <member name="M:Lucene.Net.Index.CompoundFileReader.CSInputStream.ReadInternal(System.Byte[],System.Int32,System.Int32)">
            <summary>Expert: implements buffer refill.  Reads bytes from the current
            position in the input.
            </summary>
            <param name="b">the array to read bytes into
            </param>
            <param name="offset">the offset in the array to start storing bytes
            </param>
            <param name="length">the number of bytes to read
            </param>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.CSInputStream.SeekInternal(System.Int64)">
            <summary>Expert: implements seek.  Sets current position in this file, where
            the next {@link #ReadInternal(byte[],int,int)} will occur.
            </summary>
            <seealso cref="!:#ReadInternal(byte[],int,int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.CSInputStream.Close">
            <summary>Closes the stream to futher operations. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.CompoundFileWriter" -->
        <member name="M:Lucene.Net.Index.CompoundFileWriter.#ctor(Lucene.Net.Store.Directory,System.String)">
            <summary>Create the compound stream in the specified file. The file name is the
            entire name (no extensions are added).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileWriter.GetDirectory">
            <summary>Returns the directory of the compound file. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileWriter.GetName">
            <summary>Returns the name of the compound file. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileWriter.AddFile(System.String)">
            <summary>Add a source stream. If sourceDir is null, it is set to the
            same value as the directory where this compound stream exists.
            The id is the string by which the sub-stream will be know in the
            compound stream. The caller must ensure that the ID is unique. If the
            id is null, it is set to the name of the source file.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileWriter.Close">
            <summary>Merge files with the extensions added up to now.
            All files with these extensions are combined sequentially into the
            compound stream. After successful merge, the source files
            are deleted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileWriter.CopyFile(Lucene.Net.Index.CompoundFileWriter.FileEntry,Lucene.Net.Store.OutputStream,System.Byte[])">
            <summary>Copy the contents of the file with specified extension into the
            provided output stream. Use the provided buffer for moving data
            to reduce memory allocation.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.CompoundFileWriter.FileEntry.file">
            <summary>source file </summary>
        </member>
        <member name="F:Lucene.Net.Index.CompoundFileWriter.FileEntry.directoryOffset">
            <summary>temporary holder for the start of directory entry for this file </summary>
        </member>
        <member name="F:Lucene.Net.Index.CompoundFileWriter.FileEntry.dataOffset">
            <summary>temporary holder for the start of this file's data section </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentWriter.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Analysis.Analyzer,Lucene.Net.Search.Similarity,System.Int32)">
            <summary> </summary>
            <param name="directory">The directory to write the document information to
            </param>
            <param name="analyzer">The analyzer to use for the document
            </param>
            <param name="similarity">The Similarity function
            </param>
            <param name="maxFieldLength">The maximum number of tokens a Field may have
            </param>
        </member>
        <member name="T:Lucene.Net.Index.FieldInfos">
            <summary>Access to the Field Info file that describes document fields and whether or
            not they are indexed. Each segment has a separate Field Info file. Objects
            of this class are thread-safe for multiple readers, but only one thread can
            be adding documents at a time, with no other reader or writer threads
            accessing this object.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.#ctor(Lucene.Net.Store.Directory,System.String)">
            <summary> Construct a FieldInfos object using the directory and the name of the file
            InputStream
            </summary>
            <param name="d">The directory to open the InputStream from
            </param>
            <param name="name">The name of the file to open the InputStream from in the Directory
            </param>
            <throws>  IOException </throws>
            <summary> 
            </summary>
            <seealso cref="!:#read">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Add(Lucene.Net.Documents.Document)">
            <summary>Adds Field info for a Document. </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.AddIndexed(System.Collections.ICollection,System.Boolean)">
            <param name="names">The names of the fields
            </param>
            <param name="storeTermVectors">Whether the fields store term vectors or not
            </param>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Add(System.Collections.ICollection,System.Boolean)">
            <summary> Assumes the Field is not storing term vectors </summary>
            <param name="names">The names of the fields
            </param>
            <param name="isIndexed">Whether the fields are indexed or not
            
            </param>
            <seealso cref="!:boolean)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Add(System.String,System.Boolean)">
            <summary> Calls three parameter add with false for the storeTermVector parameter </summary>
            <param name="name">The name of the Field
            </param>
            <param name="isIndexed">true if the Field is indexed
            </param>
            <seealso cref="!:boolean, boolean)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Add(System.String,System.Boolean,System.Boolean)">
            <summary>If the Field is not yet known, adds it. If it is known, checks to make
            sure that the isIndexed flag is the same as was given previously for this
            Field. If not - marks it as being indexed.  Same goes for storeTermVector
            
            </summary>
            <param name="name">The name of the Field
            </param>
            <param name="isIndexed">true if the Field is indexed
            </param>
            <param name="storeTermVector">true if the term vector should be stored
            </param>
        </member>
        <member name="T:Lucene.Net.Index.FieldsReader">
            <summary> Class responsible for access to stored document fields.
            
            It uses &lt;segment&gt;.fdt and &lt;segment&gt;.fdx; files.
            
            </summary>
            <version>  $Id: FieldsReader.java,v 1.7 2004/03/29 22:48:02 cutting Exp $
            </version>
        </member>
        <member name="T:Lucene.Net.Index.FilterIndexReader">
            <summary>A <code>FilterIndexReader</code> contains another IndexReader, which it
            uses as its basic source of data, possibly transforming the data along the
            way or providing additional functionality. The class
            <code>FilterIndexReader</code> itself simply implements all abstract methods
            of <code>IndexReader</code> with versions that pass all requests to the
            contained index reader. Subclasses of <code>FilterIndexReader</code> may
            further override some of these methods and may also provide additional
            methods and fields.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.IndexReader" -->
        <member name="M:Lucene.Net.Index.IndexReader.#ctor(Lucene.Net.Store.Directory)">
            <summary> Constructor used if IndexReader is not owner of its directory. 
            This is used for IndexReaders that are used within other IndexReaders that take care or locking directories.
            
            </summary>
            <param name="directory">Directory where IndexReader files reside.
            </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfos,System.Boolean)">
            <summary> Constructor used if IndexReader is owner of its directory.
            If IndexReader is owner of its directory, it locks its directory in case of write operations.
            
            </summary>
            <param name="directory">Directory where IndexReader files reside.
            </param>
            <param name="segmentInfos">Used for write-l
            </param>
            <param name="">closeDirectory
            </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(System.String)">
            <summary>Returns an IndexReader reading the index in an FSDirectory in the named
            path. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(System.IO.FileInfo)">
            <summary>Returns an IndexReader reading the index in an FSDirectory in the named
            path. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(Lucene.Net.Store.Directory)">
            <summary>Returns an IndexReader reading the index in the given Directory. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Directory">
            <summary>Returns the directory this index resides in. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.LastModified(System.String)">
            <summary> Returns the time the index in the named directory was last modified. 
            
            <p>Synchronization of IndexReader and IndexWriter instances is 
            no longer done via time stamps of the segments file since the time resolution 
            depends on the hardware platform. Instead, a version number is maintained
            within the segments file, which is incremented everytime when the index is
            changed.</p>
            
            </summary>
            <deprecated>  Replaced by {@link #GetCurrentVersion(String)}
            
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.LastModified(System.IO.FileInfo)">
            <summary> Returns the time the index in the named directory was last modified. 
            
            <p>Synchronization of IndexReader and IndexWriter instances is 
            no longer done via time stamps of the segments file since the time resolution 
            depends on the hardware platform. Instead, a version number is maintained
            within the segments file, which is incremented everytime when the index is
            changed.</p>
            
            </summary>
            <deprecated>  Replaced by {@link #GetCurrentVersion(File)}
            
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.LastModified(Lucene.Net.Store.Directory)">
            <summary> Returns the time the index in the named directory was last modified. 
            
            <p>Synchronization of IndexReader and IndexWriter instances is 
            no longer done via time stamps of the segments file since the time resolution 
            depends on the hardware platform. Instead, a version number is maintained
            within the segments file, which is incremented everytime when the index is
            changed.</p>
            
            </summary>
            <deprecated>  Replaced by {@link #GetCurrentVersion(Directory)}
            
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetCurrentVersion(System.String)">
            <summary> Reads version number from segments files. The version number counts the
            number of changes of the index.
            
            </summary>
            <param name="directory">where the index resides.
            </param>
            <returns> version number.
            </returns>
            <throws>  IOException if segments file cannot be read </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetCurrentVersion(System.IO.FileInfo)">
            <summary> Reads version number from segments files. The version number counts the
            number of changes of the index.
            
            </summary>
            <param name="directory">where the index resides.
            </param>
            <returns> version number.
            </returns>
            <throws>  IOException if segments file cannot be read </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetCurrentVersion(Lucene.Net.Store.Directory)">
            <summary> Reads version number from segments files. The version number counts the
            number of changes of the index.
            
            </summary>
            <param name="directory">where the index resides.
            </param>
            <returns> version number.
            </returns>
            <throws>  IOException if segments file cannot be read. </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetTermFreqVectors(System.Int32)">
            <summary>Return an array of term frequency vectors for the specified document.
            The array contains a vector for each vectorized Field in the document.
            Each vector contains terms and frequencies for all terms
            in a given vectorized Field.
            If no such fields existed, the method returns null.
            
            </summary>
            <seealso cref="!:Field#IsTermVectorStored()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetTermFreqVector(System.Int32,System.String)">
            <summary>Return a term frequency vector for the specified document and Field. The
            vector returned contains terms and frequencies for those terms in
            the specified Field of this document, if the Field had storeTermVector
            flag set.  If the flag was not set, the method returns null.
            
            </summary>
            <seealso cref="!:Field#IsTermVectorStored()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IndexExists(System.String)">
            <summary> Returns <code>true</code> if an index exists at the specified directory.
            If the directory does not exist or if there is no index in it.
            <code>false</code> is returned.
            </summary>
            <param name="directory">the directory to check for an index
            </param>
            <returns> <code>true</code> if an index exists; <code>false</code> otherwise
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IndexExists(System.IO.FileInfo)">
            <summary> Returns <code>true</code> if an index exists at the specified directory.
            If the directory does not exist or if there is no index in it.
            </summary>
            <param name="directory">the directory to check for an index
            </param>
            <returns> <code>true</code> if an index exists; <code>false</code> otherwise
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IndexExists(Lucene.Net.Store.Directory)">
            <summary> Returns <code>true</code> if an index exists at the specified directory.
            If the directory does not exist or if there is no index in it.
            </summary>
            <param name="directory">the directory to check for an index
            </param>
            <returns> <code>true</code> if an index exists; <code>false</code> otherwise
            </returns>
            <throws>  IOException if there is a problem with accessing the index </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.NumDocs">
            <summary>Returns the number of documents in this index. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.MaxDoc">
            <summary>Returns one greater than the largest possible document number.
            This may be used to, e.g., determine how big to allocate an array which
            will have an element for every document number in an index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Document(System.Int32)">
            <summary>Returns the stored fields of the <code>n</code><sup>th</sup>
            <code>Document</code> in this index. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IsDeleted(System.Int32)">
            <summary>Returns true if document <i>n</i> has been deleted </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.HasDeletions">
            <summary>Returns true if any documents have been deleted </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Norms(System.String)">
            <summary>Returns the byte-encoded normalization factor for the named Field of
            every document.  This is used by the search code to score documents.
            
            </summary>
            <seealso cref="!:Field#SetBoost(float)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Norms(System.String,System.Byte[],System.Int32)">
            <summary>Reads the byte-encoded normalization factor for the named Field of every
            document.  This is used by the search code to score documents.
            
            </summary>
            <seealso cref="!:Field#SetBoost(float)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.SetNorm(System.Int32,System.String,System.Byte)">
            <summary>Expert: Resets the normalization factor for the named Field of the named
            document.  The norm represents the product of the Field's {@link
            Field#SetBoost(float) boost} and its {@link Similarity#LengthNorm(String,
            int) length normalization}.  Thus, to preserve the length normalization
            values when resetting this, one should base the new value upon the old.
            
            </summary>
            <seealso cref="!:#Norms(String)">
            </seealso>
            <seealso cref="!:Similarity#DecodeNorm(byte)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DoSetNorm(System.Int32,System.String,System.Byte)">
            <summary>Implements setNorm in subclass.</summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.SetNorm(System.Int32,System.String,System.Single)">
            <summary>Expert: Resets the normalization factor for the named Field of the named
            document.
            
            </summary>
            <seealso cref="!:#Norms(String)">
            </seealso>
            <seealso cref="!:Similarity#DecodeNorm(byte)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Terms">
            <summary>Returns an enumeration of all the terms in the index.
            The enumeration is ordered by Term.compareTo().  Each term
            is greater than all that precede it in the enumeration.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Terms(Lucene.Net.Index.Term)">
            <summary>Returns an enumeration of all terms after a given term.
            The enumeration is ordered by Term.compareTo().  Each term
            is greater than all that precede it in the enumeration.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DocFreq(Lucene.Net.Index.Term)">
            <summary>Returns the number of documents containing the term <code>t</code>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.TermDocs(Lucene.Net.Index.Term)" -->
        <member name="M:Lucene.Net.Index.IndexReader.TermDocs">
            <summary>Returns an unpositioned {@link TermDocs} enumerator. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.TermPositions(Lucene.Net.Index.Term)" -->
        <member name="M:Lucene.Net.Index.IndexReader.TermPositions">
            <summary>Returns an unpositioned {@link TermPositions} enumerator. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.AquireWriteLock">
            <summary> Trys to acquire the WriteLock on this directory.
            this method is only valid if this IndexReader is directory owner.
            
            </summary>
            <throws>  IOException If WriteLock cannot be acquired. </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Delete(System.Int32)">
            <summary>Deletes the document numbered <code>docNum</code>.  Once a document is
            deleted it will not appear in TermDocs or TermPostitions enumerations.
            Attempts to read its Field with the {@link #document}
            method will result in an error.  The presence of this document may still be
            reflected in the {@link #docFreq} statistic, though
            this will be corrected eventually as the index is further modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DoDelete(System.Int32)">
            <summary>Implements deletion of the document numbered <code>docNum</code>.
            Applications should call {@link #Delete(int)} or {@link #Delete(Term)}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Delete(Lucene.Net.Index.Term)">
            <summary>Deletes all documents containing <code>term</code>.
            This is useful if one uses a document Field to hold a unique ID string for
            the document.  Then to delete such a document, one merely constructs a
            term with the appropriate Field and the unique ID string as its text and
            passes it to this method.  Returns the number of documents deleted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.UndeleteAll">
            <summary>Undeletes all documents currently marked as deleted in this index.</summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DoUndeleteAll">
            <summary>Implements actual undeleteAll() in subclass. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Commit">
            <summary> Commit changes resulting from delete, undeleteAll, or setNorm operations
            
            </summary>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DoCommit">
            <summary>Implements commit. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Close">
            <summary> Closes files associated with this index.
            Also saves any new deletions to disk.
            No other methods should be called after this has been called.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DoClose">
            <summary>Implements close. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Finalize">
            <summary>Release the write lock, if needed. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetFieldNames">
            <summary> Returns a list of all unique Field names that exist in the index pointed
            to by this IndexReader.
            </summary>
            <returns> Collection of Strings indicating the names of the fields
            </returns>
            <throws>  IOException if there is a problem with accessing the index </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetFieldNames(System.Boolean)">
            <summary> Returns a list of all unique Field names that exist in the index pointed
            to by this IndexReader.  The boolean argument specifies whether the fields
            returned are indexed or not.
            </summary>
            <param name="indexed"><code>true</code> if only indexed fields should be returned;
            <code>false</code> if only unindexed fields should be returned.
            </param>
            <returns> Collection of Strings indicating the names of the fields
            </returns>
            <throws>  IOException if there is a problem with accessing the index </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetIndexedFieldNames(System.Boolean)">
            <summary> </summary>
            <param name="storedTermVector">if true, returns only Indexed fields that have term vector info, 
            else only indexed fields without term vector info 
            </param>
            <returns> Collection of Strings indicating the names of the fields
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IsLocked(Lucene.Net.Store.Directory)">
            <summary> Returns <code>true</code> iff the index in the named directory is
            currently locked.
            </summary>
            <param name="directory">the directory to check for a lock
            </param>
            <throws>  IOException if there is a problem with accessing the index </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IsLocked(System.String)">
            <summary> Returns <code>true</code> iff the index in the named directory is
            currently locked.
            </summary>
            <param name="directory">the directory to check for a lock
            </param>
            <throws>  IOException if there is a problem with accessing the index </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.Unlock(Lucene.Net.Store.Directory)" -->
        <member name="T:Lucene.Net.Store.Lock.With">
            <summary>Utility class for executing code with exclusive access. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.Lock" -->
        <member name="M:Lucene.Net.Store.Lock.Obtain">
            <summary>Attempts to obtain exclusive access and immediately return
            upon success or failure.
            </summary>
            <returns> true iff exclusive access is obtained
            </returns>
        </member>
        <member name="M:Lucene.Net.Store.Lock.Obtain(System.Int64)">
            <summary>Attempts to obtain an exclusive lock within amount
            of time given. Currently polls once per second until
            lockWaitTimeout is passed.
            </summary>
            <param name="lockWaitTimeout">length of time to wait in ms
            </param>
            <returns> true if lock was obtained
            </returns>
            <throws>  IOException if lock wait times out or obtain() throws an IOException </throws>
        </member>
        <member name="M:Lucene.Net.Store.Lock.Release">
            <summary>Releases exclusive access. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.IsLocked">
            <summary>Returns true if the resource is currently locked.  Note that one must
            still call {@link #Obtain()} before using the resource. 
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.Lock.With">
            <summary>Utility class for executing code with exclusive access. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.With.#ctor(Lucene.Net.Store.Lock)">
            <summary>Constructs an executor that will grab the named lock.
            Defaults lockWaitTimeout to Lock.COMMIT_LOCK_TIMEOUT.
            </summary>
            <deprecated> Kept only to avoid breaking existing code.
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Store.Lock.With.#ctor(Lucene.Net.Store.Lock,System.Int64)">
            <summary>Constructs an executor that will grab the named lock. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.With.DoBody">
            <summary>Code to execute with exclusive access. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.With.Run">
            <summary>Calls {@link #doBody} while <i>lock</i> is obtained.  Blocks if lock
            cannot be obtained immediately.  Retries to obtain lock once per second
            until it is obtained, or until it has tried ten times. Lock is released when
            {@link #doBody} exits. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterIndexReader.#ctor(Lucene.Net.Index.IndexReader)">
            <summary> <p>Construct a FilterIndexReader based on the specified base reader.
            Directory locking for delete, undeleteAll, and setNorm operations is
            left to the base reader.</p>
            <p>Note that base reader is closed if this FilterIndexReader is closed.</p>
            </summary>
            <param name="in">specified base reader.
            </param>
        </member>
        <member name="M:Lucene.Net.Index.FilterIndexReader.GetIndexedFieldNames(System.Boolean)">
            <summary> </summary>
            <param name="storedTermVector">if true, returns only Indexed fields that have term vector info, 
            else only indexed fields without term vector info 
            </param>
            <returns> Collection of Strings indicating the names of the fields
            </returns>
        </member>
        <member name="T:Lucene.Net.Index.FilterIndexReader.FilterTermDocs">
            <summary>Base class for filtering {@link TermDocs} implementations. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TermDocs" -->
        <member name="M:Lucene.Net.Index.TermDocs.Seek(Lucene.Net.Index.Term)">
            <summary>Sets this to the data for a term.
            The enumeration is reset to the start of the data for this term.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermDocs.Seek(Lucene.Net.Index.TermEnum)">
            <summary>Sets this to the data for the current term in a {@link TermEnum}.
            This may be optimized in some implementations.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermDocs.Doc" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermDocs.Freq" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermDocs.Next" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermDocs.Read(System.Int32[],System.Int32[])" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermDocs.SkipTo(System.Int32)" -->
        <member name="M:Lucene.Net.Index.TermDocs.Close">
            <summary>Frees associated resources. </summary>
        </member>
        <member name="T:Lucene.Net.Index.FilterIndexReader.FilterTermPositions">
            <summary>Base class for filtering {@link TermPositions} implementations. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TermPositions" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermPositions.NextPosition" -->
        <member name="T:Lucene.Net.Index.FilterIndexReader.FilterTermEnum">
            <summary>Base class for filtering {@link TermEnum} implementations. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TermEnum" -->
        <member name="M:Lucene.Net.Index.TermEnum.Next">
            <summary>Increments the enumeration to the next element.  True if one exists.</summary>
        </member>
        <member name="M:Lucene.Net.Index.TermEnum.Term">
            <summary>Returns the current Term in the enumeration.</summary>
        </member>
        <member name="M:Lucene.Net.Index.TermEnum.DocFreq">
            <summary>Returns the docFreq of the current Term in the enumeration.</summary>
        </member>
        <member name="M:Lucene.Net.Index.TermEnum.Close">
            <summary>Closes the enumeration to further activity, freeing resources. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermEnum.SkipTo(Lucene.Net.Index.Term)" -->
        <member name="T:Lucene.Net.Index.IndexWriter">
            <summary>An IndexWriter creates and maintains an index.
            The third argument to the <a href="#IndexWriter"><b>constructor</b></a>
            determines whether a new index is created, or whether an existing index is
            opened for the addition of new documents.
            In either case, documents are added with the <a
            href="#addDocument"><b>addDocument</b></a> method.  When finished adding
            documents, <a href="#close"><b>close</b></a> should be called.
            If an index will not have more documents added for a while and optimal search
            performance is desired, then the <a href="#optimize"><b>optimize</b></a>
            method should be called before the index is closed.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.WRITE_LOCK_TIMEOUT">
            <summary> Default value is 1000.  Use <code>Lucene.Net.writeLockTimeout</code>
            system property to override.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.COMMIT_LOCK_TIMEOUT">
            <summary> Default value is 10000.  Use <code>Lucene.Net.commitLockTimeout</code>
            system property to override.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.DEFAULT_MERGE_FACTOR">
            <summary> Default value is 10.  Use <code>Lucene.Net.mergeFactor</code>
            system property to override.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.DEFAULT_MIN_MERGE_DOCS">
            <summary> Default value is 10.  Use <code>Lucene.Net.minMergeDocs</code>
            system property to override.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.DEFAULT_MAX_MERGE_DOCS">
            <summary> Default value is {@link Integer#MAX_VALUE}.
            Use <code>Lucene.Net.maxMergeDocs</code> system property to override.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.DEFAULT_MAX_FIELD_LENGTH">
            <summary> Default value is 10000.  Use <code>Lucene.Net.maxFieldLength</code>
            system property to override.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.useCompoundFile">
            <summary>Use compound file setting. Defaults to true, minimizing the number of
            files used.  Setting this to false may improve indexing performance, but
            may also cause file handle problems.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetUseCompoundFile">
            <summary>Setting to turn on usage of a compound file. When on, multiple files
            for each segment are merged into a single file once the segment creation
            is finished. This is done regardless of what directory is in use.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetUseCompoundFile(System.Boolean)">
            <summary>Setting to turn on usage of a compound file. When on, multiple files
            for each segment are merged into a single file once the segment creation
            is finished. This is done regardless of what directory is in use.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetSimilarity(Lucene.Net.Search.Similarity)">
            <summary>Expert: Set the Similarity implementation used by this IndexWriter.
            
            </summary>
            <seealso cref="!:Similarity#SetDefault(Similarity)">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.GetSimilarity" -->
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(System.String,Lucene.Net.Analysis.Analyzer,System.Boolean)">
            <summary> Constructs an IndexWriter for the index in <code>path</code>.
            Text will be analyzed with <code>a</code>.  If <code>create</code>
            is true, then a new, empty index will be created in
            <code>path</code>, replacing the index already there, if any.
            
            </summary>
            <param name="path">the path to the index directory
            </param>
            <param name="a">the analyzer to use
            </param>
            <param name="create"><code>true</code> to create the index or overwrite
            the existing one; <code>false</code> to append to the existing
            index
            </param>
            <throws>  IOException if the directory cannot be read/written to, or </throws>
            <summary>  if it does not exist, and <code>create</code> is
            <code>false</code>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(System.IO.FileInfo,Lucene.Net.Analysis.Analyzer,System.Boolean)">
            <summary> Constructs an IndexWriter for the index in <code>path</code>.
            Text will be analyzed with <code>a</code>.  If <code>create</code>
            is true, then a new, empty index will be created in
            <code>path</code>, replacing the index already there, if any.
            
            </summary>
            <param name="path">the path to the index directory
            </param>
            <param name="a">the analyzer to use
            </param>
            <param name="create"><code>true</code> to create the index or overwrite
            the existing one; <code>false</code> to append to the existing
            index
            </param>
            <throws>  IOException if the directory cannot be read/written to, or </throws>
            <summary>  if it does not exist, and <code>create</code> is
            <code>false</code>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Analysis.Analyzer,System.Boolean)">
            <summary> Constructs an IndexWriter for the index in <code>d</code>.
            Text will be analyzed with <code>a</code>.  If <code>create</code>
            is true, then a new, empty index will be created in
            <code>d</code>, replacing the index already there, if any.
            
            </summary>
            <param name="d">the index directory
            </param>
            <param name="a">the analyzer to use
            </param>
            <param name="create"><code>true</code> to create the index or overwrite
            the existing one; <code>false</code> to append to the existing
            index
            </param>
            <throws>  IOException if the directory cannot be read/written to, or </throws>
            <summary>  if it does not exist, and <code>create</code> is
            <code>false</code>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Close">
            <summary>Flushes all changes to an index and closes all associated files. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Finalize">
            <summary>Release the write lock, if needed. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetAnalyzer">
            <summary>Returns the analyzer used by this index. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DocCount">
            <summary>Returns the number of documents currently in this index. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.maxFieldLength">
            <summary> The maximum number of terms that will be indexed for a single Field in a
            document.  This limits the amount of memory required for indexing, so that
            collections with very large files will not crash the indexing process by
            running out of memory.<p/>
            Note that this effectively truncates large documents, excluding from the
            index terms that occur further in the document.  If you know your source
            documents are large, be sure to set this value high enough to accomodate
            the expected size.  If you set it to Integer.MAX_VALUE, then the only limit
            is your memory, but you should anticipate an OutOfMemoryError.<p/>
            By default, no more than 10,000 terms will be indexed for a Field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.AddDocument(Lucene.Net.Documents.Document)">
            <summary> Adds a document to this index.  If the document contains more than
            {@link #maxFieldLength} terms for a given Field, the remainder are
            discarded.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.AddDocument(Lucene.Net.Documents.Document,Lucene.Net.Analysis.Analyzer)">
            <summary> Adds a document to this index, using the provided analyzer instead of the
            value of {@link #GetAnalyzer()}.  If the document contains more than
            {@link #maxFieldLength} terms for a given Field, the remainder are
            discarded.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Index.IndexWriter.mergeFactor" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Index.IndexWriter.minMergeDocs" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Index.IndexWriter.maxMergeDocs" -->
        <member name="F:Lucene.Net.Index.IndexWriter.infoStream">
            <summary>If non-null, information about merges will be printed to this. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Optimize">
            <summary>Merges all segments together into a single segment, optimizing an index
            for search. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.AddIndexes(Lucene.Net.Store.Directory[])" -->
        <member name="M:Lucene.Net.Index.IndexWriter.AddIndexes(Lucene.Net.Index.IndexReader[])">
            <summary>Merges the provided indexes into this index.
            <p>After this completes, the index is optimized. </p>
            <p>The provided IndexReaders are not closed.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.FlushRamSegments">
            <summary>Merges all RAM-resident segments. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MaybeMergeSegments">
            <summary>Incremental segment merger.  </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MergeSegments(System.Int32)">
            <summary>Pops segments off of segmentInfos stack down to minSegment, merges them,
            and pushes the merged index onto the top of the segmentInfos stack. 
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultipleTermPositions">
            <summary> Describe class <code>MultipleTermPositions</code> here.
            
            </summary>
            <author>  Anders Nielsen
            </author>
            <version>  1.0
            </version>
        </member>
        <member name="M:Lucene.Net.Index.MultipleTermPositions.#ctor(Lucene.Net.Index.IndexReader,Lucene.Net.Index.Term[])">
            <summary> Creates a new <code>MultipleTermPositions</code> instance.
            
            </summary>
            <param name="indexReader">an <code>IndexReader</code> value
            </param>
            <param name="terms">a <code>Term[]</code> value
            </param>
            <exception cref="!:"> IOException if an error occurs
            </exception>
        </member>
        <member name="M:Lucene.Net.Index.MultipleTermPositions.Next">
            <summary> Describe <code>next</code> method here.
            
            </summary>
            <returns> a <code>boolean</code> value
            </returns>
            <exception cref="!:"> IOException if an error occurs
            </exception>
            <seealso cref="!:TermDocs#Next()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.MultipleTermPositions.NextPosition">
            <summary> Describe <code>nextPosition</code> method here.
            
            </summary>
            <returns> an <code>int</code> value
            </returns>
            <exception cref="!:"> IOException if an error occurs
            </exception>
            <seealso cref="!:TermPositions#NextPosition()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.MultipleTermPositions.SkipTo(System.Int32)">
            <summary> Describe <code>skipTo</code> method here.
            
            </summary>
            <param name="target">an <code>int</code> value
            </param>
            <returns> a <code>boolean</code> value
            </returns>
            <exception cref="!:"> IOException if an error occurs
            </exception>
            <seealso cref="!:TermDocs#SkipTo(int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.MultipleTermPositions.Doc">
            <summary> Describe <code>doc</code> method here.
            
            </summary>
            <returns> an <code>int</code> value
            </returns>
            <seealso cref="!:TermDocs#Doc()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.MultipleTermPositions.Freq">
            <summary> Describe <code>freq</code> method here.
            
            </summary>
            <returns> an <code>int</code> value
            </returns>
            <seealso cref="!:TermDocs#Freq()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.MultipleTermPositions.Close">
            <summary> Describe <code>close</code> method here.
            
            </summary>
            <exception cref="!:"> IOException if an error occurs
            </exception>
            <seealso cref="!:TermDocs#Close()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.MultipleTermPositions.Seek(Lucene.Net.Index.Term)">
            <summary> Describe <code>seek</code> method here.
            
            </summary>
            <param name="arg0">a <code>Term</code> value
            </param>
            <exception cref="!:"> IOException if an error occurs
            </exception>
            <seealso cref="!:TermDocs#Seek(Term)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.MultipleTermPositions.Read(System.Int32[],System.Int32[])">
            <summary> Describe <code>read</code> method here.
            
            </summary>
            <param name="arg0">an <code>int[]</code> value
            </param>
            <param name="arg1">an <code>int[]</code> value
            </param>
            <returns> an <code>int</code> value
            </returns>
            <exception cref="!:"> IOException if an error occurs
            </exception>
            <seealso cref="!:int[])">
            </seealso>
        </member>
        <member name="T:Lucene.Net.Util.PriorityQueue">
            <summary>A PriorityQueue maintains a partial ordering of its elements such that the
            least element can always be found in constant time.  Put()'s and pop()'s
            require log(size) time. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.LessThan(System.Object,System.Object)">
            <summary>Determines the ordering of objects in this priority queue.  Subclasses
            must define this one method. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Initialize(System.Int32)">
            <summary>Subclass constructors must call this. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Put(System.Object)">
            <summary> Adds an Object to a PriorityQueue in log(size) time.
            If one tries to add more objects than maxSize from initialize
            a RuntimeException (ArrayIndexOutOfBound) is thrown.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Insert(System.Object)">
            <summary> Adds element to the PriorityQueue in log(size) time if either
            the PriorityQueue is not full, or not lessThan(element, top()).
            </summary>
            <param name="">element
            </param>
            <returns> true if element is added, false otherwise.
            </returns>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Top">
            <summary>Returns the least element of the PriorityQueue in constant time. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Pop">
            <summary>Removes and returns the least element of the PriorityQueue in log(size)
            time. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.AdjustTop">
            <summary>Should be called when the Object at top changes values.  Still log(n)
            worst case, but it's at least twice as fast to <pre>
            { pq.top().change(); pq.adjustTop(); }
            </pre> instead of <pre>
            { o = pq.pop(); o.change(); pq.push(o); }
            </pre>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Size">
            <summary>Returns the number of elements currently stored in the PriorityQueue. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Clear">
            <summary>Removes all entries from the PriorityQueue. </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiReader">
            <summary>An IndexReader which reads multiple indexes, appending their content.
            
            </summary>
            <version>  $Id: MultiReader.java,v 1.7 2004/05/17 12:56:47 goller Exp $
            </version>
        </member>
        <member name="M:Lucene.Net.Index.MultiReader.#ctor(Lucene.Net.Index.IndexReader[])">
            <summary> <p>Construct a MultiReader aggregating the named set of (sub)readers.
            Directory locking for delete, undeleteAll, and setNorm operations is
            left to the subreaders. </p>
            <p>Note that all subreaders are closed if this Multireader is closed.</p>
            </summary>
            <param name="subReaders">set of (sub)readers
            </param>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.MultiReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfos,System.Boolean,Lucene.Net.Index.IndexReader[])">
            <summary>Construct reading the named set of readers. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiReader.GetTermFreqVectors(System.Int32)">
            <summary>Return an array of term frequency vectors for the specified document.
            The array contains a vector for each vectorized Field in the document.
            Each vector vector contains term numbers and frequencies for all terms
            in a given vectorized Field.
            If no such fields existed, the method returns null.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiReader.GetFieldNames">
            <seealso cref="!:IndexReader#GetFieldNames()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.MultiReader.GetFieldNames(System.Boolean)">
            <seealso cref="!:IndexReader#GetFieldNames(boolean)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.MultiTermDocs.Read(System.Int32[],System.Int32[])">
            <summary>Optimized implementation. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiTermDocs.SkipTo(System.Int32)">
            <summary>As yet unoptimized implementation. </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.FORMAT">
            <summary>The file format version, a negative number. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetVersion">
            <summary> version number when this SegmentInfos was generated.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.ReadCurrentVersion(Lucene.Net.Store.Directory)">
            <summary> Current version number from segments file.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.SegmentMerger" -->
        <member name="M:Lucene.Net.Index.SegmentMerger.#ctor(Lucene.Net.Store.Directory,System.String,System.Boolean)">
            <summary> </summary>
            <param name="dir">The Directory to merge the other segments into
            </param>
            <param name="name">The name of the new segment
            </param>
            <param name="compoundFile">true if the new segment should use a compoundFile
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.Add(Lucene.Net.Index.IndexReader)">
            <summary> Add an IndexReader to the collection of readers that are to be merged</summary>
            <param name="">reader
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.SegmentReader(System.Int32)">
            <summary> </summary>
            <param name="i">The index of the reader to return
            </param>
            <returns> The ith reader to be merged
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.Merge">
            <summary> Merges the readers specified by the {@link #add} method into the directory passed to the constructor</summary>
            <returns> The number of documents that were merged
            </returns>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.CloseReaders">
            <summary> close all IndexReaders that have been added.
            Should not be called before merge().
            </summary>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.MergeFields">
            <summary> </summary>
            <returns> The number of documents in all of the readers
            </returns>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.MergeVectors">
            <summary> Merge the TermVectors from each of the segments into the new one.</summary>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.MergeTermInfo(Lucene.Net.Index.SegmentMergeInfo[],System.Int32)">
            <summary>Merge one term found in one or more segments. The array <code>smis</code>
            contains segments that are positioned at the same term. <code>N</code>
            is the number of cells in the array actually occupied.
            
            </summary>
            <param name="smis">array of segments
            </param>
            <param name="n">number of cells in the array actually occupied
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.AppendPostings(Lucene.Net.Index.SegmentMergeInfo[],System.Int32)">
            <summary>Process postings from multiple segments all positioned on the
            same term. Writes out merged entries into freqOutput and
            the proxOutput streams.
            
            </summary>
            <param name="smis">array of segments
            </param>
            <param name="n">number of cells in the array actually occupied
            </param>
            <returns> number of documents across all segments where this term was found
            </returns>
        </member>
        <member name="T:Lucene.Net.Index.SegmentReader">
            <summary> FIXME: Describe class <code>SegmentReader</code> here.
            
            </summary>
            <version>  $Id: SegmentReader.java,v 1.23 2004/07/10 06:19:01 otis Exp $
            </version>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.GetFieldNames">
            <seealso cref="!:IndexReader#GetFieldNames()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.GetFieldNames(System.Boolean)">
            <seealso cref="!:IndexReader#GetFieldNames(boolean)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.GetIndexedFieldNames(System.Boolean)">
            <summary> </summary>
            <param name="storedTermVector">if true, returns only Indexed fields that have term vector info, 
            else only indexed fields without term vector info 
            </param>
            <returns> Collection of Strings indicating the names of the fields
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.Norms(System.String,System.Byte[],System.Int32)">
            <summary>Read norms into a pre-allocated array. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.GetTermFreqVector(System.Int32,System.String)">
            <summary>Return a term frequency vector for the specified document and Field. The
            vector returned contains term numbers and frequencies for all terms in
            the specified Field of this document, if the Field had storeTermVector
            flag set.  If the flag was not set, the method returns null.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.GetTermFreqVectors(System.Int32)">
            <summary>Return an array of term frequency vectors for the specified document.
            The array contains a vector for each vectorized Field in the document.
            Each vector vector contains term numbers and frequencies for all terms
            in a given vectorized Field.
            If no such fields existed, the method returns null.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermDocs.Read(System.Int32[],System.Int32[])">
            <summary>Optimized implementation. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermDocs.SkipProx(System.Int64)">
            <summary>Overridden by SegmentTermPositions to skip in prox stream. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermDocs.SkipTo(System.Int32)">
            <summary>Optimized implementation. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.Next">
            <summary>Increments the enumeration to the next element.  True if one exists.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.Term">
            <summary>Returns the current Term in the enumeration.
            Initially invalid, valid after next() called for the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.TermInfo">
            <summary>Returns the current TermInfo in the enumeration.
            Initially invalid, valid after next() called for the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.TermInfo(Lucene.Net.Index.TermInfo)">
            <summary>Sets the argument to the current TermInfo in the enumeration.
            Initially invalid, valid after next() called for the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.DocFreq">
            <summary>Returns the docFreq from the current TermInfo in the enumeration.
            Initially invalid, valid after next() called for the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.Close">
            <summary>Closes the enumeration to further activity, freeing resources. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermPositions.SkipProx(System.Int64)">
            <summary>Called by base.SkipTo(). </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermFreqVector">
            <summary>Provides access to stored term vector of 
            a document Field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermFreqVector.GetField">
            <summary> </summary>
            <returns> The Field this vector is associated with.
            
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.TermFreqVector.Size">
            <returns> The number of terms in the term vector.
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.TermFreqVector.GetTerms">
            <returns> An Array of term texts in ascending order.
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.TermFreqVector.GetTermFrequencies">
            <summary>Array of term frequencies. Locations of the array correspond one to one
            to the terms in the array obtained from <code>getTerms</code>
            method. Each location in the array contains the number of times this
            term occurs in the document or the document Field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermFreqVector.IndexOf(System.String)">
            <summary>Return an index in the term numbers array returned from
            <code>getTerms</code> at which the term with the specified
            <code>term</code> appears. If this term does not appear in the array,
            return -1.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermFreqVector.IndexesOf(System.String[],System.Int32,System.Int32)">
            <summary>Just like <code>indexOf(int)</code> but searches for a number of terms
            at the same time. Returns an array that has the same size as the number
            of terms searched for, each slot containing the result of searching for
            that term number.
            
            </summary>
            <param name="terms">array containing terms to look for
            </param>
            <param name="start">index in the array where the list of terms starts
            </param>
            <param name="len">the number of terms in the list
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermVector.GetField">
            <summary> </summary>
            <returns> The number of the Field this vector is associated with
            </returns>
        </member>
        <member name="T:Lucene.Net.Index.Term">
            <summary>A Term represents a word from text.  This is the unit of search.  It is
            composed of two elements, the text of the word, as a string, and the name of
            the Field that the text occured in, an interned string.
            Note that terms may represent more than words from text fields, but also
            things like dates, email addresses, urls, etc.  
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.#ctor(System.String,System.String)">
            <summary>Constructs a Term with the given Field and text. </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.Field">
            <summary>Returns the Field of this term, an interned string.   The Field indicates
            the part of a document which this term came from. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.Text">
            <summary>Returns the text of this term.  In the case of words, this is simply the
            text of the word.  In the case of dates and other types, this is an
            encoding of the object as a string.  
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.Equals(System.Object)">
            <summary>Compares two terms, returning true iff they have the same
            Field and text. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.GetHashCode">
            <summary>Combines the hashCode() of the Field and the text. </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.CompareTo(Lucene.Net.Index.Term)">
            <summary>Compares two terms, returning an integer which is less than zero iff this
            term belongs after the argument, equal zero iff this term is equal to the
            argument, and greater than zero iff this term belongs after the argument.
            The ordering of terms is first by Field, then by text.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.Set(System.String,System.String)">
            <summary>Resets the Field and text of a Term. </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermInfo">
            <summary>A TermInfo is the record of information stored for a term.</summary>
        </member>
        <member name="F:Lucene.Net.Index.TermInfo.docFreq">
            <summary>The number of documents which contain the term. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TermInfosReader" -->
        <member name="M:Lucene.Net.Index.TermInfosReader.Size">
            <summary>Returns the number of term/value pairs in the set. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.GetIndexOffset(Lucene.Net.Index.Term)">
            <summary>Returns the offset of the greatest index entry which is less than or equal to term.</summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.Get(Lucene.Net.Index.Term)">
            <summary>Returns the TermInfo for a Term in the set, or null. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.ScanEnum(Lucene.Net.Index.Term)">
            <summary>Scans within block for matching term. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.Get(System.Int32)">
            <summary>Returns the nth term in the set. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.GetPosition(Lucene.Net.Index.Term)">
            <summary>Returns the position of a Term in the set or -1. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.Terms">
            <summary>Returns an enumeration of all the Terms and TermInfos in the set. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.Terms(Lucene.Net.Index.Term)">
            <summary>Returns an enumeration of terms starting at or after the named term. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TermInfosWriter" -->
        <member name="F:Lucene.Net.Index.TermInfosWriter.FORMAT">
            <summary>The file format version, a negative number. </summary>
        </member>
        <member name="F:Lucene.Net.Index.TermInfosWriter.indexInterval">
            <summary>Expert: The fraction of terms in the "dictionary" which should be stored
            in RAM.  Smaller values use more memory, but make searching slightly
            faster, while larger values use less memory and make searching slightly
            slower.  Searching is typically not dominated by dictionary lookup, so
            tweaking this is rarely useful.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.TermInfosWriter.skipInterval">
            <summary>Expert: The fraction of {@link TermDocs} entries stored in skip tables,
            used to accellerate {@link TermDocs#SkipTo(int)}.  Larger values result in
            smaller indexes, greater acceleration, but fewer accelerable cases, while
            smaller values result in bigger indexes, less acceleration and more
            accelerable cases. More detailed experiments would be useful here. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermInfosWriter.Add(Lucene.Net.Index.Term,Lucene.Net.Index.TermInfo)" -->
        <member name="M:Lucene.Net.Index.TermInfosWriter.Close">
            <summary>Called to complete TermInfos creation. </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermPositionVector">
            <summary>Extends <code>TermFreqVector</code> to provide additional information about
            positions in which each of the terms is found.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermPositionVector.GetTermPositions(System.Int32)">
            <summary>Returns an array of positions in which the term is found.
            Terms are identified by the index at which its number appears in the
            term number array obtained from <code>getTermNumbers</code> method.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermVectorsReader">
            <summary>TODO: relax synchro!</summary>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsReader.Size">
            <summary> </summary>
            <returns> The number of documents in the reader
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsReader.Get(System.Int32,System.String)">
            <summary> Retrieve the term vector for the given document and Field</summary>
            <param name="docNum">The document number to retrieve the vector for
            </param>
            <param name="Field">The Field within the document to retrieve
            </param>
            <returns> The TermFreqVector for the document and Field or null
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsReader.Get(System.Int32)">
            <summary>Return all term vectors stored for this document or null if the could not be read in. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsReader.ReadTermVector(System.String,System.Int64)">
            <summary> </summary>
            <param name="fieldNum">The Field to read in
            </param>
            <param name="tvfPointer">The pointer within the tvf file where we should start reading
            </param>
            <returns> The TermVector located at that position
            </returns>
            <throws>  IOException </throws>
        </member>
        <member name="T:Lucene.Net.Index.TermVectorsWriter">
            <summary> Writer works by opening a document and then opening the fields within the document and then
            writing out the vectors for each Field.
            
            Rough usage:
            
            <CODE>
            for each document
            {
            writer.openDocument();
            for each Field on the document
            {
            writer.openField(Field);
            for all of the terms
            {
            writer.addTerm(...)
            }
            writer.closeField
            }
            writer.closeDocument()    
            }
            </CODE>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsWriter.#ctor(Lucene.Net.Store.Directory,System.String,Lucene.Net.Index.FieldInfos)">
            <summary>Create term vectors writer for the specified segment in specified
            directory.  A new TermVectorsWriter should be created for each
            segment. The parameter <code>maxFields</code> indicates how many total
            fields are found in this document. Not all of these fields may require
            termvectors to be stored, so the number of calls to
            <code>openField</code> is less or equal to this number.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsWriter.OpenField(System.String)">
            <summary>Start processing a Field. This can be followed by a number of calls to
            addTerm, and a final call to closeField to indicate the end of
            processing of this Field. If a Field was previously open, it is
            closed automatically.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsWriter.CloseField">
            <summary>Finished processing current Field. This should be followed by a call to
            openField before future calls to addTerm.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsWriter.IsFieldOpen">
            <summary>Return true if a Field is currently open. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsWriter.AddTerm(System.String,System.Int32)">
            <summary>Add term to the Field's term vector. Field must already be open
            of NullPointerException is thrown. Terms should be added in
            increasing order of terms, one call per unique termNum. ProxPointer
            is a pointer into the TermPosition file (prx). Freq is the number of
            times this term appears in this Field, in this document.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsWriter.AddVectors(Lucene.Net.Index.TermFreqVector[])">
            <summary>Add specified vectors to the document.</summary>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsWriter.AddTermFreqVector(Lucene.Net.Index.TermFreqVector)">
            <summary>Add specified vector to the document. Document must be open but no Field
            should be open or exception is thrown. The same document can have <code>addTerm</code>
            and <code>addVectors</code> calls mixed, however a given Field must either be
            populated with <code>addTerm</code> or with <code>addVector</code>.     *
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsWriter.Close">
            <summary>Close all streams. </summary>
        </member>
        <member name="T:Lucene.Net.QueryParsers.CharStream">
            <summary> This interface describes a character stream that maintains line and
            column number positions of the characters.  It also has the capability
            to backup the stream to some extent.  An implementation of this
            interface is used in the TokenManager implementation generated by
            JavaCCParser.
            
            All the methods except backup can be implemented in any fashion. backup
            needs to be implemented correctly for the correct operation of the lexer.
            Rest of the methods are all used to get information like line number,
            column number and the String that constitutes a token and are not used
            by the lexer. Hence their implementation won't affect the generated lexer's
            operation.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.ReadChar">
            <summary> Returns the next character from the selected input.  The method
            of selecting the input is the responsibility of the class
            implementing this interface.  Can throw any java.io.IOException.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetColumn">
            <summary> Returns the column position of the character last read.</summary>
            <deprecated> 
            </deprecated>
            <seealso cref="!:#getEndColumn">
            </seealso>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetLine">
            <summary> Returns the line number of the character last read.</summary>
            <deprecated> 
            </deprecated>
            <seealso cref="!:#getEndLine">
            </seealso>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetEndColumn">
            <summary> Returns the column number of the last character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetEndLine">
            <summary> Returns the line number of the last character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetBeginColumn">
            <summary> Returns the column number of the first character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetBeginLine">
            <summary> Returns the line number of the first character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.Backup(System.Int32)">
            <summary> Backs up the input stream by amount steps. Lexer calls this method if it
            had already read some characters, but could not use them to match a
            (longer) token. So, they will be used again as the prefix of the next
            token and it is the implemetation's responsibility to do this right.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.BeginToken">
            <summary> Returns the next character that marks the beginning of the next token.
            All characters must remain in the buffer between two successive calls
            to this method to implement backup correctly.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetImage">
            <summary> Returns a string made up of characters from the marked token beginning 
            to the current buffer position. Implementations have the choice of returning
            anything that they want to. For example, for efficiency, one might decide
            to just return null, which is a valid implementation.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetSuffix(System.Int32)">
            <summary> Returns an array of characters that make up the suffix of length 'len' for
            the currently matched token. This is used to build up the matched string
            for use in actions in the case of MORE. A simple and inefficient
            implementation of this is as follows :
            
            {
            String t = GetImage();
            return t.substring(t.length() - len, t.length()).toCharArray();
            }
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.Done">
            <summary> The lexer calls this function to indicate that it is done with the stream
            and hence implementations can free any resources held by this class.
            Again, the body of this function can be just empty and it will not
            affect the lexer's operation.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.QueryParsers.FastCharStream" -->
        <member name="M:Lucene.Net.QueryParsers.FastCharStream.#ctor(System.IO.TextReader)">
            <summary>Constructs from a Reader. </summary>
        </member>
        <member name="T:Lucene.Net.QueryParsers.MultiFieldQueryParser">
            <summary> A QueryParser which constructs queries to search multiple fields.
            
            </summary>
            <author>  <a href="mailto:kelvin@relevanz.com">Kelvin Tan</a>
            </author>
            <version>  $Revision: 1.4 $
            </version>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.QueryParsers.QueryParser" -->
        <member name="F:Lucene.Net.QueryParsers.QueryParser.operator_Renamed">
            <summary>The actual operator that parser uses to combine query terms </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParser.lowercaseWildcardTerms">
            <summary> Whether terms of wildcard and prefix queries are to be automatically
            lower-cased or not.  Default is <code>true</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.Parse(System.String,System.String,Lucene.Net.Analysis.Analyzer)">
            <summary>Parses a query string, returning a {@link Lucene.Net.Search.Query}.</summary>
            <param name="query"> the query string to be parsed.
            </param>
            <param name="field"> the default Field for query terms.
            </param>
            <param name="analyzer">  used to find terms in the query text.
            </param>
            <throws>  ParseException if the parsing fails </throws>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.#ctor(System.String,Lucene.Net.Analysis.Analyzer)">
            <summary>Constructs a query parser.</summary>
            <param name="f"> the default Field for query terms.
            </param>
            <param name="a">  used to find terms in the query text.
            </param>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.Parse(System.String)">
            <summary>Parses a query string, returning a
            <a href="lucene.search.Query.html">Query</a>.
            </summary>
            <param name="query"> the query string to be parsed.
            </param>
            <throws>  ParseException if the parsing fails </throws>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetAnalyzer">
            <returns> Returns the analyzer.
            </returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetField">
            <returns> Returns the field.
            </returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetFuzzyMinSim">
            <summary> Get the default minimal similarity for fuzzy queries.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetFuzzyMinSim(System.Single)">
            <summary>Set the default minimum similarity for fuzzy queries.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetPhraseSlop(System.Int32)">
            <summary> Sets the default slop for phrases.  If zero, then exact phrase matches
            are required.  Default value is zero.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetPhraseSlop">
            <summary> Gets the default slop for phrases.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetOperator(System.Int32)">
            <summary> Sets the boolean operator of the QueryParser.
            In classic mode (<code>DEFAULT_OPERATOR_OR</code>) terms without any modifiers
            are considered optional: for example <code>capital of Hungary</code> is equal to
            <code>capital OR of OR Hungary</code>.<br/>
            In <code>DEFAULT_OPERATOR_AND</code> terms are considered to be in conjuction: the
            above mentioned query is parsed as <code>capital AND of AND Hungary</code>
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetOperator">
            <summary> Gets implicit operator setting, which will be either DEFAULT_OPERATOR_AND
            or DEFAULT_OPERATOR_OR.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetLocale(System.Globalization.CultureInfo)">
            <summary> Set locale used by date range parsing.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetLocale">
            <summary> Returns current locale, allowing access by subclasses.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetFieldQuery(System.String,Lucene.Net.Analysis.Analyzer,System.String)">
            <summary> Note that parameter analyzer is ignored. Calls inside the parser always
            use class member analyser. This method will be deprecated and substituted
            by {@link #GetFieldQuery(String, String)} in future versions of Lucene.
            Currently overwriting either of these methods works.
            
            </summary>
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetFieldQuery(System.String,System.String)">
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetFieldQuery(System.String,Lucene.Net.Analysis.Analyzer,System.String,System.Int32)">
            <summary> Base implementation delegates to {@link #GetFieldQuery(String, Analyzer, String)}.
            This method may be overwritten, for example, to return
            a SpanNearQuery instead of a PhraseQuery.
            
            Note that parameter analyzer is ignored. Calls inside the parser always
            use class member analyser. This method will be deprecated and substituted
            by {@link #GetFieldQuery(String, String, int)} in future versions of Lucene.
            Currently overwriting either of these methods works.
            
            </summary>
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetFieldQuery(System.String,System.String,System.Int32)">
            <summary> Base implementation delegates to {@link #GetFieldQuery(String,String)}.
            This method may be overridden, for example, to return
            a SpanNearQuery instead of a PhraseQuery.
            
            </summary>
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetRangeQuery(System.String,Lucene.Net.Analysis.Analyzer,System.String,System.String,System.Boolean)">
            <summary> Note that parameter analyzer is ignored. Calls inside the parser always
            use class member analyser. This method will be deprecated and substituted
            by {@link #GetRangeQuery(String, String, String, boolean)} in future versions of Lucene.
            Currently overwriting either of these methods works.
            
            </summary>
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetRangeQuery(System.String,System.String,System.String,System.Boolean)">
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetBooleanQuery(System.Collections.ArrayList)">
            <summary> Factory method for generating query, given a set of clauses.
            By default creates a boolean query composed of clauses passed in.
            
            Can be overridden by extending classes, to modify query being
            returned.
            
            </summary>
            <param name="clauses">Vector that contains {@link BooleanClause} instances
            to join.
            
            </param>
            <returns> Resulting {@link Query} object.
            </returns>
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.QueryParser.GetWildcardQuery(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.QueryParser.GetPrefixQuery(System.String,System.String)" -->
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetFuzzyQuery(System.String,System.String)">
            <summary> Factory method for generating a query (similar to
            ({@link #getWildcardQuery}). Called when parser parses
            an input term token that has the fuzzy suffix (~) appended.
            
            </summary>
            <param name="field">Name of the field query will use.
            </param>
            <param name="termStr">Term token to use for building term for the query
            
            </param>
            <returns> Resulting {@link Query} built for the term
            </returns>
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetFuzzyQuery(System.String,System.String,System.Single)">
            <summary> Factory method for generating a query (similar to
            ({@link #getWildcardQuery}). Called when parser parses
            an input term token that has the fuzzy suffix (~floatNumber) appended.
            
            </summary>
            <param name="field">Name of the field query will use.
            </param>
            <param name="termStr">Term token to use for building term for the query
            </param>
            <param name="minSimilarity">the minimum similarity required for a fuzzy match
            
            </param>
            <returns> Resulting {@link Query} built for the term
            </returns>
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.DiscardEscapeChar(System.String)">
            <summary> Returns a String where the escape char has been
            removed, or kept only once if there was a double escape.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.Escape(System.String)">
            <summary> Returns a String where those characters that QueryParser
            expects to be escaped are escaped, i.e. preceded by a <code>\</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.MultiFieldQueryParser.Parse(System.String,System.String[],Lucene.Net.Analysis.Analyzer)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.MultiFieldQueryParser.Parse(System.String,System.String[],System.Int32[],Lucene.Net.Analysis.Analyzer)" -->
        <member name="T:Lucene.Net.QueryParsers.ParseException">
            <summary> This exception is thrown when parse errors are encountered.
            You can explicitly create objects of this exception type by
            calling the method generateParseException in the generated
            parser.
            
            You can modify this class to customize your error reporting
            mechanisms so long as you retain the public fields.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.ParseException.#ctor(Lucene.Net.QueryParsers.Token,System.Int32[][],System.String[])" -->
        <member name="M:Lucene.Net.QueryParsers.ParseException.#ctor">
            <summary> The following constructors are for use by you for whatever
            purpose you can think of.  Constructing the exception in this
            manner makes the exception behave in the normal way - i.e., as
            documented in the class "Throwable".  The fields "errorToken",
            "expectedTokenSequences", and "tokenImage" do not contain
            relevant information.  The JavaCC generated code does not use
            these constructors.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.ParseException.specialConstructor">
            <summary> This variable determines which constructor was used to create
            this object and thereby affects the semantics of the
            "getMessage" method (see below).
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.ParseException.currentToken">
            <summary> This is the last token that has been consumed successfully.  If
            this object has been created due to a parse error, the token
            followng this token will (therefore) be the first error token.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.ParseException.expectedTokenSequences">
            <summary> Each entry in this array is an array of integers.  Each array
            of integers represents a sequence of tokens (by their ordinal
            values) that is expected at this point of the parse.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.ParseException.tokenImage">
            <summary> This is a reference to the "tokenImage" array of the generated
            parser within which the parse error occurred.  This array is
            defined in the generated ...Constants interface.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.ParseException.eol">
            <summary> The end of line string for this machine.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.ParseException.Add_escapes(System.String)">
            <summary> Used to convert raw characters to their escaped version
            when these raw version cannot be used as part of an ASCII
            string literal.
            </summary>
        </member>
        <member name="P:Lucene.Net.QueryParsers.ParseException.Message">
            <summary> This method has the standard behavior when this object has been
            created using the standard constructors.  Otherwise, it uses
            "currentToken" and "expectedTokenSequences" to generate a parse
            error message and returns it.  If this object has been created
            due to a parse error, and you do not catch it (it gets thrown
            from the parser), then this method is called during the printing
            of the final stack trace, and hence the correct error message
            gets displayed.
            </summary>
        </member>
        <member name="T:Lucene.Net.QueryParsers.Token">
            <summary> Describes the input token stream.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.kind">
            <summary> An integer that describes the kind of this token.  This numbering
            system is determined by JavaCCParser, and a table of these numbers is
            stored in the file ...Constants.java.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.beginLine">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.beginColumn">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.endLine">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.endColumn">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.image">
            <summary> The string image of the token.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.next">
            <summary> A reference to the next regular (non-special) token from the input
            stream.  If this is the last token from the input stream, or if the
            token manager has not read tokens beyond this one, this Field is
            set to null.  This is true only if this token is also a regular
            token.  Otherwise, see below for a description of the contents of
            this Field.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.specialToken">
            <summary> This Field is used to access special tokens that occur prior to this
            token, but after the immediately preceding regular (non-special) token.
            If there are no such special tokens, this Field is set to null.
            When there are more than one such special token, this Field refers
            to the last of these special tokens, which in turn refers to the next
            previous special token through its specialToken Field, and so on
            until the first special token (whose specialToken Field is null).
            The next fields of special tokens refer to other special tokens that
            immediately follow it (without an intervening regular token).  If there
            is no such token, this Field is null.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Token.ToString">
            <summary> Returns the image.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Token.NewToken(System.Int32)">
            <summary> Returns a new Token object, by default. However, if you want, you
            can create and return subclass objects based on the value of ofKind.
            Simply add the cases to the switch for all those special cases.
            For example, if you have a subclass of Token called IDToken that
            you want to create if ofKind is ID, simlpy add something like :
            
            case MyParserConstants.ID : return new IDToken();
            
            to the following switch statement. Then you can cast matchedToken
            variable to the appropriate type and use it in your lexical actions.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.TokenMgrError.LEXICAL_ERROR">
            <summary> Lexical error occured.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.TokenMgrError.STATIC_LEXER_ERROR">
            <summary> An attempt wass made to create a second instance of a static token manager.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.TokenMgrError.INVALID_LEXICAL_STATE">
            <summary> Tried to change to an invalid lexical state.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.TokenMgrError.LOOP_DETECTED">
            <summary> Detected (and bailed out of) an infinite loop in the token manager.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.TokenMgrError.errorCode">
            <summary> Indicates the reason why the exception is thrown. It will have
            one of the above 4 values.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.TokenMgrError.addEscapes(System.String)">
            <summary> Replaces unprintable characters by their espaced (or unicode escaped)
            equivalents in the given string
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.TokenMgrError.LexicalError(System.Boolean,System.Int32,System.Int32,System.Int32,System.String,System.Char)">
            <summary> Returns a detailed message for the Error when it is thrown by the
            token manager to indicate a lexical error.
            Parameters : 
            EOFSeen     : indicates if EOF caused the lexicl error
            curLexState : lexical state in which this error occured
            errorLine   : line number when the error occured
            errorColumn : column number when the error occured
            errorAfter  : prefix that was seen before this error occured
            curchar     : the offending character
            Note: You can customize the lexical error message by modifying this method.
            </summary>
        </member>
        <member name="P:Lucene.Net.QueryParsers.TokenMgrError.Message">
            <summary> You can also modify the body of this method to customize your error messages.
            For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
            of end-users concern, so you can return something like : 
            
            "Internal Error : Please file a bug report .... "
            
            from this method for such cases in the release version of your parser.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.Spans">
            <summary>Expert: an enumeration of span matches.  Used to implement span searching.
            Each span represents a range of term positions within a document.  Matches
            are enumerated in order, by increasing document number, within that by
            increasing start position and finally by increasing end position. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.Spans.Next">
            <summary>Move to the next match, returning true iff any such exists. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Spans.Spans.SkipTo(System.Int32)" -->
        <member name="M:Lucene.Net.Search.Spans.Spans.Doc">
            <summary>Returns the document number of the current match.  Initially invalid. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.Spans.Start">
            <summary>Returns the start position of the current match.  Initially invalid. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.Spans.End">
            <summary>Returns the end position of the current match.  Initially invalid. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.NearSpans.SpansCell">
            <summary>Wraps a Spans, and can be used to form a linked list. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanFirstQuery">
            <summary>Matches spans near the beginning of a Field. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanQuery">
            <summary>Base class for span-based queries. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Query" -->
        <member name="M:Lucene.Net.Search.Query.SetBoost(System.Single)">
            <summary>Sets the boost for this query clause to <code>b</code>.  Documents
            matching this clause will (in addition to the normal weightings) have
            their score multiplied by <code>b</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Query.GetBoost">
            <summary>Gets the boost for this clause.  Documents matching
            this clause will (in addition to the normal weightings) have their score
            multiplied by <code>b</code>.   The boost is 1.0 by default.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Query.ToString(System.String)" -->
        <member name="M:Lucene.Net.Search.Query.ToString">
            <summary>Prints a query to a string. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Query.CreateWeight(Lucene.Net.Search.Searcher)" -->
        <member name="M:Lucene.Net.Search.Query.Weight(Lucene.Net.Search.Searcher)">
            <summary>Expert: Constructs an initializes a Weight for a top-level query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Query.Rewrite(Lucene.Net.Index.IndexReader)">
            <summary>Expert: called to re-write queries into primitive queries. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Query.Combine(Lucene.Net.Search.Query[])" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Query.MergeBooleanQueries(Lucene.Net.Search.Query[])" -->
        <member name="M:Lucene.Net.Search.Query.GetSimilarity(Lucene.Net.Search.Searcher)">
            <summary>Expert: Returns the Similarity implementation to be used for this query.
            Subclasses may override this method to specify their own Similarity
            implementation, perhaps one that delegates through that of the Searcher.
            By default the Searcher's Similarity implementation is returned.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Query.Clone">
            <summary>Returns a clone of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanQuery.GetSpans(Lucene.Net.Index.IndexReader)">
            <summary>Expert: Returns the matches for this query in an index.  Used internally
            to search for spans. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanQuery.GetField">
            <summary>Returns the name of the Field matched by this query.</summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanQuery.GetTerms">
            <summary>Returns a collection of all terms matched by this query.</summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanFirstQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery,System.Int32)">
            <summary>Construct a SpanFirstQuery matching spans in <code>match</code> whose end
            position is less than or equal to <code>end</code>. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanFirstQuery.GetMatch">
            <summary>Return the SpanQuery whose matches are filtered. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanFirstQuery.GetEnd">
            <summary>Return the maximum end position permitted in a match. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanNearQuery">
            <summary>Matches spans which are near one another.  One can specify <i>slop</i>, the
            maximum number of intervening unmatched positions, as well as whether
            matches are required to be in-order. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery[],System.Int32,System.Boolean)">
            <summary>Construct a SpanNearQuery.  Matches spans matching a span from each
            clause, with up to <code>slop</code> total unmatched positions between
            them.  * When <code>inOrder</code> is true, the spans from each clause
            must be * ordered as in <code>clauses</code>. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.GetClauses">
            <summary>Return the clauses whose spans are matched. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.GetSlop">
            <summary>Return the maximum number of intervening unmatched positions permitted.</summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.IsInOrder">
            <summary>Return true if matches are required to be in-order.</summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanNotQuery">
            <summary>Removes matches which overlap with another SpanQuery. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery,Lucene.Net.Search.Spans.SpanQuery)">
            <summary>Construct a SpanNotQuery matching spans from <code>include</code> which
            have no overlap with spans from <code>exclude</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.GetInclude">
            <summary>Return the SpanQuery whose matches are filtered. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.GetExclude">
            <summary>Return the SpanQuery whose matches must not overlap those returned. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanOrQuery">
            <summary>Matches the union of its clauses.</summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanOrQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery[])">
            <summary>Construct a SpanOrQuery merging the provided clauses. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanOrQuery.GetClauses">
            <summary>Return the clauses whose spans are matched. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Scorer">
            <summary>Expert: Implements scoring for a class of queries. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Scorer.#ctor(Lucene.Net.Search.Similarity)">
            <summary>Constructs a Scorer. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Scorer.GetSimilarity">
            <summary>Returns the Similarity implementation used by this scorer. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Scorer.Score(Lucene.Net.Search.HitCollector)">
            <summary>Scores all documents and passes them to a collector. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Scorer.Next">
            <summary>Advance to the next document matching the query.  Returns true iff there
            is another match. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Scorer.Doc">
            <summary>Returns the current document number.  Initially invalid, until {@link
            #Next()} is called the first time. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Scorer.Score">
            <summary>Returns the score of the current document.  Initially invalid, until
            {@link #Next()} is called the first time. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Scorer.SkipTo(System.Int32)" -->
        <member name="M:Lucene.Net.Search.Scorer.Explain(System.Int32)">
            <summary>Returns an explanation of the score for <code>doc</code>. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanTermQuery">
            <summary>Matches spans containing a term. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanTermQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>Construct a SpanTermQuery matching the named term's spans. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanTermQuery.GetTerm">
            <summary>Return the term whose spans are matched. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Weight" -->
        <member name="M:Lucene.Net.Search.Weight.SumOfSquaredWeights">
            <summary>The sum of squared weights of contained query clauses. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Weight.Normalize(System.Single)">
            <summary>Assigns the query normalization factor to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Weight.Scorer(Lucene.Net.Index.IndexReader)">
            <summary>Constructs a scorer for this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Weight.Explain(Lucene.Net.Index.IndexReader,System.Int32)">
            <summary>An explanation of the score computation for the named document. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Weight.Query">
            <summary>The query that this concerns. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Weight.Value">
            <summary>The weight for this query. </summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanClause">
            <summary>A clause in a BooleanQuery. </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanClause.query">
            <summary>The query whose matching documents are combined by the boolean query. </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanClause.required">
            <summary>If true, documents documents which <i>do not</i>
            match this sub-query will <i>not</i> match the boolean query. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanClause.prohibited">
            <summary>If true, documents documents which <i>do</i>
            match this sub-query will <i>not</i> match the boolean query. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanClause.#ctor(Lucene.Net.Search.Query,System.Boolean,System.Boolean)">
            <summary>Constructs a BooleanClause with query <code>q</code>, required
            <code>r</code> and prohibited <code>p</code>. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanClause.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanClause.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanQuery">
            <summary>A Query that matches documents matching boolean combinations of other
            queries, typically {@link TermQuery}s or {@link PhraseQuery}s.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanQuery.maxClauseCount">
            <summary> Default value is 1024.  Use <code>Lucene.Net.maxClauseCount</code>
            system property to override.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.GetMaxClauseCount">
            <summary>Return the maximum number of clauses permitted, 1024 by default.
            Attempts to add more than the permitted number of clauses cause {@link
            TooManyClauses} to be thrown.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.SetMaxClauseCount(System.Int32)">
            <summary>Set the maximum number of clauses permitted. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.#ctor">
            <summary>Constructs an empty boolean query. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.BooleanQuery.Add(Lucene.Net.Search.Query,System.Boolean,System.Boolean)" -->
        <member name="M:Lucene.Net.Search.BooleanQuery.Add(Lucene.Net.Search.BooleanClause)">
            <summary>Adds a clause to a boolean query.</summary>
            <seealso cref="!:#GetMaxClauseCount()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.GetClauses">
            <summary>Returns the set of clauses in this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanQuery.TooManyClauses">
            <summary>Thrown when an attempt is made to add more than {@link
            #GetMaxClauseCount()} clauses. 
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanScorer.BucketTable">
            <summary>A simple hash table of document scores within a range. </summary>
        </member>
        <member name="T:Lucene.Net.Search.HitCollector">
            <summary>Lower-level search API.</summary>
            <seealso cref="!:Searcher#Search(Query,HitCollector)">
            </seealso>
            <version>  $Id: HitCollector.java,v 1.6 2004/03/29 22:48:03 cutting Exp $
            </version>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.HitCollector.Collect(System.Int32,System.Single)" -->
        <member name="T:Lucene.Net.Search.CachingWrapperFilter">
            <summary> Wraps another filters result and caches it.  The caching
            behavior is like {@link QueryFilter}.  The purpose is to allow
            filters to simply filter, and then wrap with this class to add
            caching, keeping the two concerns decoupled yet composable.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Filter">
            <summary>Abstract base class providing a mechanism to restrict searches to a subset
            of an index. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Filter.Bits(Lucene.Net.Index.IndexReader)">
            <summary>Returns a BitSet with true for documents which should be permitted in
            search results, and false for those that should not. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.CachingWrapperFilter.cache">
            <todo>  What about serialization in RemoteSearchable?  Caching won't work. </todo>
            <summary>       Should transient be removed?
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.CachingWrapperFilter.#ctor(Lucene.Net.Search.Filter)">
            <param name="filter">Filter to cache results of
            </param>
        </member>
        <member name="T:Lucene.Net.Search.ConjunctionScorer">
            <summary>Scorer for conjunctions, sets of queries, all of which are required. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.DateFilter" -->
        <member name="M:Lucene.Net.Search.DateFilter.#ctor(System.String,System.DateTime,System.DateTime)">
            <summary> Constructs a filter for Field <code>f</code> matching dates
            between <code>from</code> and <code>to</code> inclusively.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DateFilter.#ctor(System.String,System.Int64,System.Int64)">
            <summary> Constructs a filter for Field <code>f</code> matching times
            between <code>from</code> and <code>to</code> inclusively.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DateFilter.Before(System.String,System.DateTime)">
            <summary> Constructs a filter for Field <code>f</code> matching
            dates on or before before <code>date</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DateFilter.Before(System.String,System.Int64)">
            <summary> Constructs a filter for Field <code>f</code> matching times
            on or before <code>time</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DateFilter.After(System.String,System.DateTime)">
            <summary> Constructs a filter for Field <code>f</code> matching
            dates on or after <code>date</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DateFilter.After(System.String,System.Int64)">
            <summary> Constructs a filter for Field <code>f</code> matching
            times on or after <code>time</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DateFilter.Bits(Lucene.Net.Index.IndexReader)">
            <summary> Returns a BitSet with true for documents which should be
            permitted in search results, and false for those that should
            not.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.DefaultSimilarity">
            <summary>Expert: Default scoring implementation. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarity" -->
        <member name="F:Lucene.Net.Search.Similarity.defaultImpl">
            <summary>The Similarity implementation used by default. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarity.SetDefault(Lucene.Net.Search.Similarity)">
            <summary>Set the default Similarity implementation used by indexing and search
            code.
            
            </summary>
            <seealso cref="!:Searcher#SetSimilarity(Similarity)">
            </seealso>
            <seealso cref="!:IndexWriter#SetSimilarity(Similarity)">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.GetDefault" -->
        <member name="F:Lucene.Net.Search.Similarity.NORM_TABLE">
            <summary>Cache of decoded bytes. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarity.DecodeNorm(System.Byte)">
            <summary>Decodes a normalization factor stored in an index.</summary>
            <seealso cref="!:#EncodeNorm(float)">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.LengthNorm(System.String,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.QueryNorm(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.EncodeNorm(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.Tf(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.SloppyFreq(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.Tf(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.Idf(Lucene.Net.Index.Term,Lucene.Net.Search.Searcher)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.Idf(System.Collections.ICollection,Lucene.Net.Search.Searcher)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.Idf(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.Coord(System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Search.DefaultSimilarity.LengthNorm(System.String,System.Int32)">
            <summary>Implemented as <code>1/sqrt(numTerms)</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DefaultSimilarity.QueryNorm(System.Single)">
            <summary>Implemented as <code>1/sqrt(sumOfSquaredWeights)</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DefaultSimilarity.Tf(System.Single)">
            <summary>Implemented as <code>sqrt(freq)</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DefaultSimilarity.SloppyFreq(System.Int32)">
            <summary>Implemented as <code>1 / (distance + 1)</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DefaultSimilarity.Idf(System.Int32,System.Int32)">
            <summary>Implemented as <code>log(numDocs/(docFreq+1)) + 1</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DefaultSimilarity.Coord(System.Int32,System.Int32)">
            <summary>Implemented as <code>overlap / maxOverlap</code>. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Explanation">
            <summary>Expert: Describes the score computation for document and query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.GetValue">
            <summary>The value assigned to this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.SetValue(System.Single)">
            <summary>Sets the value assigned to this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.GetDescription">
            <summary>A description of this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.SetDescription(System.String)">
            <summary>Sets the description of this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.GetDetails">
            <summary>The sub-nodes of this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.AddDetail(Lucene.Net.Search.Explanation)">
            <summary>Adds a sub-node to this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.ToString">
            <summary>Render an explanation as text. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.ToHtml">
            <summary>Render an explanation as HTML. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.StringIndex" -->
        <member name="F:Lucene.Net.Search.StringIndex.lookup">
            <summary>All the term values, in natural order. </summary>
        </member>
        <member name="F:Lucene.Net.Search.StringIndex.order">
            <summary>For each document, an index into the lookup array. </summary>
        </member>
        <member name="M:Lucene.Net.Search.StringIndex.#ctor(System.Int32[],System.String[])">
            <summary>Creates one of these objects </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache_Fields.STRING_INDEX">
            <summary>Indicator for StringIndex values in the cache. </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache_Fields.DEFAULT">
            <summary>Expert: The cache used internally by sorting and range query classes. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetInts(Lucene.Net.Index.IndexReader,System.String)">
            <summary>Checks the internal cache for an appropriate entry, and if none is
            found, reads the terms in <code>Field</code> as integers and returns an array
            of size <code>reader.maxDoc()</code> of the value each document
            has in the given Field.
            </summary>
            <param name="reader"> Used to get Field values.
            </param>
            <param name="Field">  Which Field contains the integers.
            </param>
            <returns> The values in the given Field for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetFloats(Lucene.Net.Index.IndexReader,System.String)">
            <summary>Checks the internal cache for an appropriate entry, and if
            none is found, reads the terms in <code>Field</code> as floats and returns an array
            of size <code>reader.maxDoc()</code> of the value each document
            has in the given Field.
            </summary>
            <param name="reader"> Used to get Field values.
            </param>
            <param name="Field">  Which Field contains the floats.
            </param>
            <returns> The values in the given Field for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetStrings(Lucene.Net.Index.IndexReader,System.String)">
            <summary>Checks the internal cache for an appropriate entry, and if none
            is found, reads the term values in <code>Field</code> and returns an array
            of size <code>reader.maxDoc()</code> containing the value each document
            has in the given Field.
            </summary>
            <param name="reader"> Used to get Field values.
            </param>
            <param name="Field">  Which Field contains the strings.
            </param>
            <returns> The values in the given Field for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetStringIndex(Lucene.Net.Index.IndexReader,System.String)">
            <summary>Checks the internal cache for an appropriate entry, and if none
            is found reads the term values in <code>Field</code> and returns
            an array of them in natural order, along with an array telling
            which element in the term array each document uses.
            </summary>
            <param name="reader"> Used to get Field values.
            </param>
            <param name="Field">  Which Field contains the strings.
            </param>
            <returns> Array of terms and index into the array for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetAuto(Lucene.Net.Index.IndexReader,System.String)">
            <summary>Checks the internal cache for an appropriate entry, and if
            none is found reads <code>Field</code> to see if it contains integers, floats
            or strings, and then calls one of the other methods in this class to get the
            values.  For string values, a StringIndex is returned.  After
            calling this method, there is an entry in the cache for both
            type <code>AUTO</code> and the actual found type.
            </summary>
            <param name="reader"> Used to get Field values.
            </param>
            <param name="Field">  Which Field contains the values.
            </param>
            <returns> int[], float[] or StringIndex.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetCustom(Lucene.Net.Index.IndexReader,System.String,Lucene.Net.Search.SortComparator)">
            <summary>Checks the internal cache for an appropriate entry, and if none
            is found reads the terms out of <code>Field</code> and calls the given SortComparator
            to get the sort values.  A hit in the cache will happen if <code>reader</code>,
            <code>Field</code>, and <code>comparator</code> are the same (using <code>equals()</code>)
            as a previous call to this method.
            </summary>
            <param name="reader"> Used to get Field values.
            </param>
            <param name="Field">  Which Field contains the values.
            </param>
            <param name="comparator">Used to convert terms into something to sort by.
            </param>
            <returns> Array of sort objects, one for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FieldCacheImpl" -->
        <member name="F:Lucene.Net.Search.FieldCacheImpl.cache">
            <summary>The internal cache. Maps Entry to array of interpreted term values. *</summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Lookup(Lucene.Net.Index.IndexReader,System.String,System.Int32)">
            <summary>See if an object is in the cache. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Lookup(Lucene.Net.Index.IndexReader,System.String,System.Object)">
            <summary>See if a custom object is in the cache. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Store(Lucene.Net.Index.IndexReader,System.String,System.Int32,System.Object)">
            <summary>Put an object into the cache. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Store(Lucene.Net.Index.IndexReader,System.String,System.Object,System.Object)">
            <summary>Put a custom object into the cache. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.GetAuto(Lucene.Net.Index.IndexReader,System.String)">
            <summary>The pattern used to detect float values in a Field </summary>
            <summary> removed for java 1.3 compatibility
            protected static final Object pFloats = Pattern.compile ("[0-9+\\-\\.eEfFdD]+");
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.Entry">
            <summary>Expert: Every key in the internal cache is of this type. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Entry.#ctor(System.String,System.Int32)">
            <summary>Creates one of these objects. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Entry.#ctor(System.String,System.Object)">
            <summary>Creates one of these objects for a custom comparator. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Entry.Equals(System.Object)">
            <summary>Two of these are equal iff they reference the same field and type. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Entry.GetHashCode">
            <summary>Composes a hashcode based on the field and type. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FieldDoc" -->
        <member name="T:Lucene.Net.Search.ScoreDoc">
            <summary>Expert: Returned by low-level search implementations.</summary>
            <seealso cref="T:Lucene.Net.Search.TopDocs">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Search.ScoreDoc.score">
            <summary>Expert: The score of this document for the query. </summary>
        </member>
        <member name="F:Lucene.Net.Search.ScoreDoc.doc">
            <summary>Expert: A hit document's number.</summary>
            <seealso cref="!:Searcher#Doc(int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.ScoreDoc.#ctor(System.Int32,System.Single)">
            <summary>Expert: Constructs a ScoreDoc. </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldDoc.fields">
            <summary>Expert: The values which are used to sort the referenced document.
            The order of these will match the original sort criteria given by a
            Sort object.  Each Object will be either an Integer, Float or String,
            depending on the type of values in the terms of the original Field.
            </summary>
            <seealso cref="T:Lucene.Net.Search.Sort">
            </seealso>
            <seealso cref="!:Searchable#Search(Query,Filter,int,Sort)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.FieldDoc.#ctor(System.Int32,System.Single)">
            <summary>Expert: Creates one of these objects with empty sort information. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldDoc.#ctor(System.Int32,System.Single,System.IComparable[])">
            <summary>Expert: Creates one of these objects with the given sort information. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FieldDocSortedHitQueue" -->
        <member name="M:Lucene.Net.Search.FieldDocSortedHitQueue.#ctor(Lucene.Net.Search.SortField[],System.Int32)">
            <summary> Creates a hit queue sorted by the given list of fields.</summary>
            <param name="fields">Field names, in priority order (highest priority first).
            </param>
            <param name="size"> The number of hits to retain.  Must be greater than zero.
            </param>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldDocSortedHitQueue.SetFields(Lucene.Net.Search.SortField[])">
            <summary> Allows redefinition of sort fields if they are <code>null</code>.
            This is to handle the case using ParallelMultiSearcher where the
            original list contains AUTO and we don't know the actual sort
            type until the values come back.  The fields can only be set once.
            This method is thread safe.
            </summary>
            <param name="">fields
            </param>
        </member>
        <member name="M:Lucene.Net.Search.FieldDocSortedHitQueue.GetFields">
            <summary>Returns the fields being used to sort. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldDocSortedHitQueue.HasCollators(Lucene.Net.Search.SortField[])">
            <summary>Returns an array of collators, possibly <code>null</code>.  The collators
            correspond to any SortFields which were given a specific locale.
            </summary>
            <param name="fields">Array of sort fields.
            </param>
            <returns> Array, possibly <code>null</code>.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.FieldDocSortedHitQueue.LessThan(System.Object,System.Object)">
            <summary> Returns whether <code>a</code> is less relevant than <code>b</code>.</summary>
            <param name="a">ScoreDoc
            </param>
            <param name="b">ScoreDoc
            </param>
            <returns> <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FieldSortedHitQueue" -->
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.#ctor(Lucene.Net.Index.IndexReader,Lucene.Net.Search.SortField[],System.Int32)">
            <summary> Creates a hit queue sorted by the given list of fields.</summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fields">Field names, in priority order (highest priority first).  Cannot be <code>null</code> or empty.
            </param>
            <param name="size"> The number of hits to retain.  Must be greater than zero.
            </param>
            <throws>  IOException </throws>
        </member>
        <member name="F:Lucene.Net.Search.FieldSortedHitQueue.comparators">
            <summary>Stores a comparator corresponding to each Field being sorted by </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldSortedHitQueue.fields">
            <summary>Stores the sort criteria being used. </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldSortedHitQueue.maxscore">
            <summary>Stores the maximum score value encountered, for normalizing.
            we only care about scores greater than 1.0 - if all the scores
            are less than 1.0, we don't have to normalize. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.LessThan(System.Object,System.Object)">
            <summary> Returns whether <code>a</code> is less relevant than <code>b</code>.</summary>
            <param name="a">ScoreDoc
            </param>
            <param name="b">ScoreDoc
            </param>
            <returns> <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.FillFields(Lucene.Net.Search.FieldDoc)">
            <summary> Given a FieldDoc object, stores the values used
            to sort the given document.  These values are not the raw
            values out of the index, but the internal representation
            of them.  This is so the given search hit can be collated
            by a MultiSearcher with other search hits.
            </summary>
            <param name="doc"> The FieldDoc to store sort values into.
            </param>
            <returns>  The same FieldDoc passed in.
            </returns>
            <seealso cref="!:Searchable#Search(Query,Filter,int,Sort)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.GetFields">
            <summary>Returns the SortFields being used by this hit queue. </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldSortedHitQueue.Comparators">
            <summary>Internal cache of comparators. Similar to FieldCache, only
            caches comparators instead of term values. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.Lookup(Lucene.Net.Index.IndexReader,System.String,System.Int32,System.Object)">
            <summary>Returns a comparator if it is in the cache. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.Store(Lucene.Net.Index.IndexReader,System.String,System.Int32,System.Object,System.Object)">
            <summary>Stores a comparator into the cache. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.ComparatorInt(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Returns a comparator for sorting hits according to a Field containing integers.</summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fieldname"> Field containg integer values.
            </param>
            <returns>  Comparator for sorting hits.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.ComparatorFloat(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Returns a comparator for sorting hits according to a Field containing floats.</summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fieldname"> Field containg float values.
            </param>
            <returns>  Comparator for sorting hits.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.ComparatorString(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Returns a comparator for sorting hits according to a Field containing strings.</summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fieldname"> Field containg string values.
            </param>
            <returns>  Comparator for sorting hits.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.ComparatorStringLocale(Lucene.Net.Index.IndexReader,System.String,System.Globalization.CultureInfo)">
            <summary> Returns a comparator for sorting hits according to a Field containing strings.</summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fieldname"> Field containg string values.
            </param>
            <returns>  Comparator for sorting hits.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.ComparatorAuto(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Returns a comparator for sorting hits according to values in the given Field.
            The terms in the Field are looked at to determine whether they contain integers,
            floats or strings.  Once the type is determined, one of the other static methods
            in this class is called to get the comparator.
            </summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fieldname"> Field containg values.
            </param>
            <returns>  Comparator for sorting hits.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.ScoreDocComparator.Compare(Lucene.Net.Search.ScoreDoc,Lucene.Net.Search.ScoreDoc)" -->
        <member name="M:Lucene.Net.Search.ScoreDocComparator.SortValue(Lucene.Net.Search.ScoreDoc)">
            <summary> Returns the value used to sort the given document.  The
            object returned must implement the java.io.Serializable
            interface.  This is used by multisearchers to determine how to collate results from their searchers.
            </summary>
            <seealso cref="T:Lucene.Net.Search.FieldDoc">
            </seealso>
            <param name="i">Document
            </param>
            <returns> Serializable object
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.ScoreDocComparator.SortType">
            <summary> Returns the type of sort.  Should return <code>SortField.SCORE</code>, <code>SortField.DOC</code>, <code>SortField.STRING</code>, <code>SortField.INTEGER</code>, 
            <code>SortField.FLOAT</code> or <code>SortField.CUSTOM</code>.  It is not valid to return <code>SortField.AUTO</code>.
            This is used by multisearchers to determine how to collate results from their searchers.
            </summary>
            <returns> One of the constants in SortField.
            </returns>
            <seealso cref="T:Lucene.Net.Search.SortField">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FilteredQuery" -->
        <member name="M:Lucene.Net.Search.FilteredQuery.#ctor(Lucene.Net.Search.Query,Lucene.Net.Search.Filter)">
            <summary> Constructs a new query which applies a filter to the results of the original query.
            Filter.bits() will be called every time this query is used in a search.
            </summary>
            <param name="query"> Query to be filtered, cannot be <code>null</code>.
            </param>
            <param name="filter">Filter to apply to query results, cannot be <code>null</code>.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.CreateWeight(Lucene.Net.Search.Searcher)">
            <summary> Returns a Weight that applies the filter to the enclosed query's Weight.
            This is accomplished by overriding the Scorer returned by the Weight.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.Rewrite(Lucene.Net.Index.IndexReader)">
            <summary>Rewrites the wrapped query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.GetHashCode">
            <summary>Returns a hash code value for this object. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FilteredTermEnum" -->
        <member name="M:Lucene.Net.Search.FilteredTermEnum.TermCompare(Lucene.Net.Index.Term)">
            <summary>Equality compare on the term </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredTermEnum.Difference">
            <summary>Equality measure on the term </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredTermEnum.EndEnum">
            <summary>Indiciates the end of the enumeration has been reached </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredTermEnum.DocFreq">
            <summary> Returns the docFreq of the current Term in the enumeration.
            Initially invalid, valid after next() called for the first time. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredTermEnum.Next">
            <summary>Increments the enumeration to the next element.  True if one exists. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredTermEnum.Term">
            <summary>Returns the current Term in the enumeration.
            Initially invalid, valid after next() called for the first time. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredTermEnum.Close">
            <summary>Closes the enumeration to further activity, freeing resources.  </summary>
        </member>
        <member name="T:Lucene.Net.Search.FuzzyQuery">
            <summary>Implements the fuzzy search query. The similiarity measurement
            is based on the Levenshtein (edit distance) algorithm.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.MultiTermQuery" -->
        <member name="M:Lucene.Net.Search.MultiTermQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>Constructs a query for terms matching <code>term</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.GetTerm">
            <summary>Returns the pattern term. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.GetEnum(Lucene.Net.Index.IndexReader)">
            <summary>Construct the enumeration to be used, expanding the pattern term. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.#ctor(Lucene.Net.Index.Term,System.Single,System.Int32)">
            <summary> Create a new FuzzyQuery that will match terms with a similarity 
            of at least <code>minimumSimilarity</code> to <code>term</code>.
            If a <code>prefixLength</code> &gt; 0 is specified, a common prefix
            of that length is also required.
            
            </summary>
            <param name="term">the term to search for
            </param>
            <param name="minimumSimilarity">a value between 0 and 1 to set the required similarity
            between the query term and the matching terms. For example, for a
            <code>minimumSimilarity</code> of <code>0.5</code> a term of the same length
            as the query term is considered similar to the query term if the edit distance
            between both terms is less than <code>length(term)*0.5</code>
            </param>
            <param name="prefixLength">length of common (non-fuzzy) prefix
            </param>
            <throws>  IllegalArgumentException if minimumSimilarity is &gt; 1 or &lt; 0 </throws>
            <summary> or if prefixLength &lt; 0 or &gt; <code>term.text().length()</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.#ctor(Lucene.Net.Index.Term,System.Single)">
            <summary> Calls {@link #FuzzyQuery(Term, float) FuzzyQuery(term, minimumSimilarity, 0)}.</summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.#ctor(Lucene.Net.Index.Term)">
            <summary> Calls {@link #FuzzyQuery(Term, float) FuzzyQuery(term, 0.5f, 0)}.</summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.GetMinSimilarity">
            <summary> Returns the minimum similarity that is required for this query to match.</summary>
            <returns> float value between 0.0 and 1.0
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.GetPrefixLength">
            <summary> Returns the prefix length, i.e. the number of characters at the start
            of a term that must be identical (not fuzzy) to the query term if the query
            is to match that term. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FuzzyTermEnum" -->
        <member name="M:Lucene.Net.Search.FuzzyTermEnum.#ctor(Lucene.Net.Index.IndexReader,Lucene.Net.Index.Term)">
            <summary> Empty prefix and minSimilarity of 0.5f are used.
            
            </summary>
            <param name="">reader
            </param>
            <param name="">term
            </param>
            <throws>  IOException </throws>
            <seealso cref="!:Term, float, int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyTermEnum.#ctor(Lucene.Net.Index.IndexReader,Lucene.Net.Index.Term,System.Single)">
            <summary> This is the standard FuzzyTermEnum with an empty prefix.
            
            </summary>
            <param name="">reader
            </param>
            <param name="">term
            </param>
            <param name="">minSimilarity
            </param>
            <throws>  IOException </throws>
            <seealso cref="!:Term, float, int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyTermEnum.#ctor(Lucene.Net.Index.IndexReader,Lucene.Net.Index.Term,System.Single,System.Int32)">
            <summary> Constructor for enumeration of all terms from specified <code>reader</code> which share a prefix of
            length <code>prefixLength</code> with <code>term</code> and which have a fuzzy similarity &gt;
            <code>minSimilarity</code>. 
            
            </summary>
            <param name="reader">Delivers terms.
            </param>
            <param name="term">Pattern term.
            </param>
            <param name="minSimilarity">Minimum required similarity for terms from the reader. Default value is 0.5f.
            </param>
            <param name="prefixLength">Length of required common prefix. Default value is 0.
            </param>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyTermEnum.TermCompare(Lucene.Net.Index.Term)">
            <summary>The termCompare method in FuzzyTermEnum uses Levenshtein distance to 
            calculate the distance between the given term and the comparing term. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyTermEnum.Min(System.Int32,System.Int32,System.Int32)">
            <summary>Finds and returns the smallest of three integers </summary>
        </member>
        <member name="F:Lucene.Net.Search.FuzzyTermEnum.e">
            <summary> This static array saves us from the time required to create a new array
            everytime editDistance is called.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FuzzyTermEnum.EditDistance(System.String,System.String,System.Int32,System.Int32)" -->
        <member name="T:Lucene.Net.Search.Hits">
            <summary>A ranked list of documents, used to hold search results. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Hits.GetMoreDocs(System.Int32)">
            <summary> Tries to add new documents to hitDocs.
            Ensures that the hit numbered <code>min</code> has been retrieved.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Hits.Length">
            <summary>Returns the total number of hits available in this set. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Hits.Doc(System.Int32)" -->
        <member name="M:Lucene.Net.Search.Hits.Score(System.Int32)">
            <summary>Returns the score for the nth document in this set. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Hits.Id(System.Int32)">
            <summary>Returns the id for the nth document in this set. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.IndexSearcher" -->
        <member name="T:Lucene.Net.Search.Searcher">
            <summary>An abstract base class for search implementations.
            Implements some common utility methods.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Searchable" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searchable.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,Lucene.Net.Search.HitCollector)" -->
        <member name="M:Lucene.Net.Search.Searchable.Close">
            <summary>Frees resources associated with this Searcher.
            Be careful not to call this method while you are still using objects
            like {@link Hits}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Searchable.DocFreq(Lucene.Net.Index.Term)">
            <summary>Expert: Returns the number of documents containing <code>term</code>.
            Called by search code to compute term weights.
            </summary>
            <seealso cref="!:IndexReader#docFreq(Term).">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Searchable.MaxDoc">
            <summary>Expert: Returns one greater than the largest possible document number.
            Called by search code to compute term weights.
            </summary>
            <seealso cref="!:IndexReader#maxDoc().">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searchable.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32)" -->
        <member name="M:Lucene.Net.Search.Searchable.Doc(System.Int32)">
            <summary>Expert: Returns the stored fields of document <code>i</code>.
            Called by {@link HitCollector} implementations.
            </summary>
            <seealso cref="!:IndexReader#document(int).">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Searchable.Rewrite(Lucene.Net.Search.Query)">
            <summary>Expert: called to re-write queries into primitive queries. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searchable.Explain(Lucene.Net.Search.Query,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searchable.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort)" -->
        <member name="M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query)">
            <summary>Returns the documents matching <code>query</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter)">
            <summary>Returns the documents matching <code>query</code> and
            <code>filter</code>. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Sort)">
            <summary>Returns documents matching <code>query</code> sorted by
            <code>sort</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,Lucene.Net.Search.Sort)">
            <summary>Returns documents matching <code>query</code> and <code>filter</code>,
            sorted by <code>sort</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.HitCollector)" -->
        <member name="F:Lucene.Net.Search.Searcher.similarity">
            <summary>The Similarity implementation used by this searcher. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Searcher.SetSimilarity(Lucene.Net.Search.Similarity)">
            <summary>Expert: Set the Similarity implementation used by this Searcher.
            
            </summary>
            <seealso cref="!:Similarity#SetDefault(Similarity)">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searcher.GetSimilarity" -->
        <member name="M:Lucene.Net.Search.IndexSearcher.#ctor(System.String)">
            <summary>Creates a searcher searching the index in the named directory. </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.#ctor(Lucene.Net.Store.Directory)">
            <summary>Creates a searcher searching the index in the provided directory. </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.#ctor(Lucene.Net.Index.IndexReader)">
            <summary>Creates a searcher searching the provided index. </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Close">
            <summary> Note that the underlying IndexReader is not closed, if
            IndexSearcher was constructed with IndexSearcher(IndexReader r).
            If the IndexReader was supplied implicitly by specifying a directory, then
            the IndexReader gets closed.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.MultiSearcher" -->
        <member name="M:Lucene.Net.Search.MultiSearcher.#ctor(Lucene.Net.Search.Searchable[])">
            <summary>Creates a searcher which searches <i>searchables</i>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiSearcher.SearcherIndex(System.Int32)">
            <summary>Call {@link #subSearcher} instead.</summary>
            <deprecated>
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Search.MultiSearcher.SubSearcher(System.Int32)">
            <summary>Returns index of the searcher for document <code>n</code> in the array
            used to construct this searcher. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiSearcher.SubDoc(System.Int32)">
            <summary>Returns the document number of document <code>n</code> within its
            sub-index. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.ParallelMultiSearcher" -->
        <member name="M:Lucene.Net.Search.ParallelMultiSearcher.#ctor(Lucene.Net.Search.Searchable[])">
            <summary>Creates a searcher which searches <i>searchables</i>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.ParallelMultiSearcher.DocFreq(Lucene.Net.Index.Term)">
            <summary> TODO: parallelize this one too</summary>
        </member>
        <member name="M:Lucene.Net.Search.ParallelMultiSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32)">
            <summary> A search implementation which spans a new thread for each
            Searchable, waits for each search to complete and merge
            the results back together.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ParallelMultiSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort)">
            <summary> A search implementation allowing sorting which spans a new thread for each
            Searchable, waits for each search to complete and merges
            the results back together.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.ParallelMultiSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,Lucene.Net.Search.HitCollector)" -->
        <member name="T:Lucene.Net.Search.MultiSearcherThread">
            <summary> A thread subclass for searching a single searchable </summary>
        </member>
        <member name="T:SupportClass.ThreadClass">
            <summary>
            Support class used to handle threads
            </summary>
        </member>
        <member name="T:IThreadRunnable">
            <summary>
            This interface should be implemented by any class whose instances are intended 
            to be executed by a thread.
            </summary>
        </member>
        <member name="M:IThreadRunnable.Run">
            <summary>
            This method has to be implemented in order that starting of the thread causes the object's 
            run method to be called in that separately executing thread.
            </summary>
        </member>
        <member name="T:SupportClass">
            <summary>
            Contains conversion support elements such as classes, interfaces and static methods.
            </summary>
        </member>
        <member name="T:SupportClass.ThreadClass">
            <summary>
            Support class used to handle threads
            </summary>
        </member>
        <member name="F:SupportClass.ThreadClass.threadField">
            <summary>
            The instance of System.Threading.Thread
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.#ctor">
            <summary>
            Initializes a new instance of the ThreadClass class
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.#ctor(System.String)">
            <summary>
            Initializes a new instance of the Thread class.
            </summary>
            <param name="Name">The name of the thread</param>
        </member>
        <member name="M:SupportClass.ThreadClass.#ctor(System.Threading.ThreadStart)">
            <summary>
            Initializes a new instance of the Thread class.
            </summary>
            <param name="Start">A ThreadStart delegate that references the methods to be invoked when this thread begins executing</param>
        </member>
        <member name="M:SupportClass.ThreadClass.#ctor(System.Threading.ThreadStart,System.String)">
            <summary>
            Initializes a new instance of the Thread class.
            </summary>
            <param name="Start">A ThreadStart delegate that references the methods to be invoked when this thread begins executing</param>
            <param name="Name">The name of the thread</param>
        </member>
        <member name="M:SupportClass.ThreadClass.Run">
            <summary>
            This method has no functionality unless the method is overridden
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.Start">
            <summary>
            Causes the operating system to change the state of the current thread instance to ThreadState.Running
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.Interrupt">
            <summary>
            Interrupts a thread that is in the WaitSleepJoin thread state
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.Join">
            <summary>
            Blocks the calling thread until a thread terminates
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.Join(System.Int64)">
            <summary>
            Blocks the calling thread until a thread terminates or the specified time elapses
            </summary>
            <param name="MiliSeconds">Time of wait in milliseconds</param>
        </member>
        <member name="M:SupportClass.ThreadClass.Join(System.Int64,System.Int32)">
            <summary>
            Blocks the calling thread until a thread terminates or the specified time elapses
            </summary>
            <param name="MiliSeconds">Time of wait in milliseconds</param>
            <param name="NanoSeconds">Time of wait in nanoseconds</param>
        </member>
        <member name="M:SupportClass.ThreadClass.Resume">
            <summary>
            Resumes a thread that has been suspended
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.Abort">
            <summary>
            Raises a ThreadAbortException in the thread on which it is invoked, 
            to begin the process of terminating the thread. Calling this method 
            usually terminates the thread
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.Abort(System.Object)">
            <summary>
            Raises a ThreadAbortException in the thread on which it is invoked, 
            to begin the process of terminating the thread while also providing
            exception information about the thread termination. 
            Calling this method usually terminates the thread.
            </summary>
            <param name="stateInfo">An object that contains application-specific information, such as state, which can be used by the thread being aborted</param>
        </member>
        <member name="M:SupportClass.ThreadClass.Suspend">
            <summary>
            Suspends the thread, if the thread is already suspended it has no effect
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.ToString">
            <summary>
            Obtain a String that represents the current Object
            </summary>
            <returns>A String that represents the current Object</returns>
        </member>
        <member name="M:SupportClass.ThreadClass.Current">
            <summary>
            Gets the currently running thread
            </summary>
            <returns>The currently running thread</returns>
        </member>
        <member name="P:SupportClass.ThreadClass.Instance">
            <summary>
            Gets the current thread instance
            </summary>
        </member>
        <member name="P:SupportClass.ThreadClass.Name">
            <summary>
            Gets or sets the name of the thread
            </summary>
        </member>
        <member name="P:SupportClass.ThreadClass.Priority">
            <summary>
            Gets or sets a value indicating the scheduling priority of a thread
            </summary>
        </member>
        <member name="P:SupportClass.ThreadClass.IsAlive">
            <summary>
            Gets a value indicating the execution status of the current thread
            </summary>
        </member>
        <member name="P:SupportClass.ThreadClass.IsBackground">
            <summary>
            Gets or sets a value indicating whether or not a thread is a background thread.
            </summary>
        </member>
        <member name="T:SupportClass.Number">
            <summary>
            A simple class for number conversions.
            </summary>
        </member>
        <member name="F:SupportClass.Number.MIN_RADIX">
            <summary>
            Min radix value.
            </summary>
        </member>
        <member name="F:SupportClass.Number.MAX_RADIX">
            <summary>
            Max radix value.
            </summary>
        </member>
        <member name="M:SupportClass.Number.ToString(System.Int64,System.Int32)">
            <summary>
            Converts a number to System.String in the specified radix.
            </summary>
            <param name="i">A number to be converted.</param>
            <param name="radix">A radix.</param>
            <returns>A System.String representation of the number in the specified redix.</returns>
        </member>
        <member name="M:SupportClass.Number.Parse(System.String,System.Int32)">
            <summary>
            Parses a number in the specified radix.
            </summary>
            <param name="s">An input System.String.</param>
            <param name="radix">A radix.</param>
            <returns>The parsed number in the specified radix.</returns>
        </member>
        <member name="T:SupportClass.Character">
            <summary>
            Mimics Java's Character class.
            </summary>
        </member>
        <member name="M:SupportClass.Character.ForDigit(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="digit"></param>
            <param name="radix"></param>
            <returns></returns>
        </member>
        <member name="P:SupportClass.Character.MAX_RADIX">
            <summary>
            </summary>
        </member>
        <member name="P:SupportClass.Character.MIN_RADIX">
            <summary>
            </summary>
        </member>
        <member name="T:SupportClass.Date">
            <summary>
            
            </summary>
        </member>
        <member name="M:SupportClass.Date.GetTime(System.DateTime)">
            <summary>
            
            </summary>
            <param name="dateTime"></param>
            <returns></returns>
        </member>
        <member name="T:SupportClass.Single">
            <summary>
            
            </summary>
        </member>
        <member name="M:SupportClass.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="style"></param>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.Single.Parse(System.String,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.Single.Parse(System.String,System.Globalization.NumberStyles)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="style"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.Single.Parse(System.String)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="T:SupportClass.AppSettings">
            <summary>
            
            </summary>
        </member>
        <member name="M:SupportClass.AppSettings.Get(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="defValue"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.AppSettings.Get(System.String,System.Int64)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="defValue"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.AppSettings.Get(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="defValue"></param>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Search.PhrasePrefixQuery">
            <summary> PhrasePrefixQuery is a generalized version of PhraseQuery, with an added
            method {@link #Add(Term[])}.
            To use this class, to search for the phrase "Microsoft app*" first use
            add(Term) on the term "Microsoft", then find all terms that has "app" as
            prefix using IndexReader.terms(Term), and use PhrasePrefixQuery.add(Term[]
            terms) to add them to the query.
            
            </summary>
            <author>  Anders Nielsen
            </author>
            <version>  1.0
            </version>
        </member>
        <member name="M:Lucene.Net.Search.PhrasePrefixQuery.SetSlop(System.Int32)">
            <summary>Sets the phrase slop for this query.</summary>
            <seealso cref="!:PhraseQuery#SetSlop(int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.PhrasePrefixQuery.GetSlop">
            <summary>Sets the phrase slop for this query.</summary>
            <seealso cref="!:PhraseQuery#GetSlop()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.PhrasePrefixQuery.Add(Lucene.Net.Index.Term)">
            <summary>Add a single term at the next position in the phrase.</summary>
            <seealso cref="!:PhraseQuery#Add(Term)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.PhrasePrefixQuery.Add(Lucene.Net.Index.Term[])">
            <summary>Add multiple terms at the next position in the phrase.  Any of the terms
            may match.
            
            </summary>
            <seealso cref="!:PhraseQuery#Add(Term)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.PhrasePrefixQuery.Add(Lucene.Net.Index.Term[],System.Int32)">
            <summary> Allows to specify the relative position of terms within the phrase.
            
            </summary>
            <seealso cref="!:int)">
            </seealso>
            <param name="">terms
            </param>
            <param name="">position
            </param>
        </member>
        <member name="M:Lucene.Net.Search.PhrasePrefixQuery.GetPositions">
            <summary> Returns the relative positions of terms in this phrase.</summary>
        </member>
        <member name="M:Lucene.Net.Search.PhrasePrefixQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="T:Lucene.Net.Search.PhraseQuery">
            <summary>A Query that matches documents containing a particular sequence of terms.
            This may be combined with other terms with a {@link BooleanQuery}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.#ctor">
            <summary>Constructs an empty phrase query. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.PhraseQuery.SetSlop(System.Int32)" -->
        <member name="M:Lucene.Net.Search.PhraseQuery.GetSlop">
            <summary>Returns the slop.  See setSlop(). </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.Add(Lucene.Net.Index.Term)">
            <summary> Adds a term to the end of the query phrase.
            The relative position of the term is the one immediately after the last term added.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.Add(Lucene.Net.Index.Term,System.Int32)">
            <summary> Adds a term to the end of the query phrase.
            The relative position of the term within the phrase is specified explicitly.
            This allows e.g. phrases with more than one term at the same position
            or phrases with gaps (e.g. in connection with stopwords).
            
            </summary>
            <param name="">term
            </param>
            <param name="">position
            </param>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.GetTerms">
            <summary>Returns the set of terms in this phrase. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.GetPositions">
            <summary> Returns the relative positions of terms in this phrase.</summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <member name="T:Lucene.Net.Search.PrefixQuery">
            <summary>A Query that matches documents containing terms with a specified prefix. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PrefixQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>Constructs a query for terms starting with <code>prefix</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PrefixQuery.GetPrefix">
            <summary>Returns the prefix of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PrefixQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.QueryFilter" -->
        <member name="M:Lucene.Net.Search.QueryFilter.#ctor(Lucene.Net.Search.Query)">
            <summary>Constructs a filter which only matches documents matching
            <code>query</code>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.QueryTermVector">
            <summary> 
            
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.QueryTermVector.#ctor(System.String[])">
            <summary> </summary>
            <param name="queryTerms">The original list of terms from the query, can contain duplicates
            </param>
        </member>
        <member name="T:Lucene.Net.Search.RangeQuery">
            <summary> A Query that matches documents within an exclusive range.
            
            </summary>
            <version>  $Id: RangeQuery.java,v 1.12 2004/03/29 22:48:03 cutting Exp $
            </version>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.#ctor(Lucene.Net.Index.Term,Lucene.Net.Index.Term,System.Boolean)">
            <summary>Constructs a query selecting all terms greater than
            <code>lowerTerm</code> but less than <code>upperTerm</code>.
            There must be at least one term and either term may be null,
            in which case there is no bound on that side, but if there are
            two terms, both terms <b>must</b> be for the same Field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.Rewrite(Lucene.Net.Index.IndexReader)">
            <summary> FIXME: Describe <code>rewrite</code> method here.
            
            </summary>
            <param name="reader">an <code>IndexReader</code> value
            </param>
            <returns> a <code>Query</code> value
            </returns>
            <exception cref="!:"> IOException if an error occurs
            </exception>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.GetField">
            <summary>Returns the Field name for this query </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.GetLowerTerm">
            <summary>Returns the lower term of this range query </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.GetUpperTerm">
            <summary>Returns the upper term of this range query </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.IsInclusive">
            <summary>Returns <code>true</code> if the range query is inclusive </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="T:Lucene.Net.Search.RemoteSearchable">
            <summary>A remote searchable implementation. </summary>
        </member>
        <member name="M:Lucene.Net.Search.RemoteSearchable.#ctor(Lucene.Net.Search.Searchable)">
            <summary>Constructs and exports a remote searcher. </summary>
        </member>
        <member name="M:Lucene.Net.Search.RemoteSearchable.Main(System.String[])">
            <summary>Exports a searcher for the index in args[0] named
            "//localhost/Searchable". 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.ScoreDocComparator_Fields" -->
        <member name="F:Lucene.Net.Search.ScoreDocComparator_Fields.RELEVANCE">
            <summary>Special comparator for sorting hits according to computed relevance (document score). </summary>
        </member>
        <member name="F:Lucene.Net.Search.ScoreDocComparator_Fields.INDEXORDER">
            <summary>Special comparator for sorting hits according to index order (document number). </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Sort" -->
        <member name="F:Lucene.Net.Search.Sort.RELEVANCE">
            <summary>Represents sorting by computed relevance. Using this sort criteria
            returns the same results as calling {@link Searcher#Search(Query) Searcher#search()}
            without a sort criteria, only with slightly more overhead. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Sort.INDEXORDER">
            <summary>Represents sorting by index order. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor">
            <summary>Sorts by computed relevance.  This is the same sort criteria as
            calling {@link Searcher#Search(Query) Searcher#search()} without a sort criteria, only with
            slightly more overhead. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor(System.String)">
            <summary>Sorts by the terms in <code>Field</code> then by index order (document
            number). The type of value in <code>Field</code> is determined
            automatically.
            </summary>
            <seealso cref="!:SortField#AUTO">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor(System.String,System.Boolean)">
            <summary>Sorts possibly in reverse by the terms in <code>Field</code> then by
            index order (document number). The type of value in <code>Field</code> is determined
            automatically.
            </summary>
            <seealso cref="!:SortField#AUTO">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor(System.String[])">
            <summary>Sorts in succession by the terms in each Field.
            The type of value in <code>Field</code> is determined
            automatically.
            </summary>
            <seealso cref="!:SortField#AUTO">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor(Lucene.Net.Search.SortField)">
            <summary>Sorts by the criteria in the given SortField. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor(Lucene.Net.Search.SortField[])">
            <summary>Sorts in succession by the criteria in each SortField. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.SetSort(System.String)">
            <summary>Sets the sort to the terms in <code>Field</code> then by index order
            (document number). 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.SetSort(System.String,System.Boolean)">
            <summary>Sets the sort to the terms in <code>Field</code> possibly in reverse,
            then by index order (document number). 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.SetSort(System.String[])">
            <summary>Sets the sort to the terms in each Field in succession. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.SetSort(Lucene.Net.Search.SortField)">
            <summary>Sets the sort to the given criteria. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.SetSort(Lucene.Net.Search.SortField[])">
            <summary>Sets the sort to the given criteria in succession. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.SortComparator" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.SortComparatorSource" -->
        <member name="M:Lucene.Net.Search.SortComparatorSource.NewComparator(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Creates a comparator for the Field in the given index.</summary>
            <param name="reader">Index to create comparator for.
            </param>
            <param name="fieldname"> Field to create comparator for.
            </param>
            <returns> Comparator of ScoreDoc objects.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.SortComparator.GetComparable(System.String)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.SortField" -->
        <member name="F:Lucene.Net.Search.SortField.SCORE">
            <summary>Sort by document score (relevancy).  Sort values are Float and higher
            values are at the front. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.DOC">
            <summary>Sort by document number (index order).  Sort values are Integer and lower
            values are at the front. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.AUTO">
            <summary>Guess type of sort based on Field contents.  A regular expression is used
            to look at the first term indexed for the Field and determine if it
            represents an integer number, a floating point number, or just arbitrary
            string characters. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.STRING">
            <summary>Sort using term values as Strings.  Sort values are String and lower
            values are at the front. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.INT">
            <summary>Sort using term values as encoded Integers.  Sort values are Integer and
            lower values are at the front. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.FLOAT">
            <summary>Sort using term values as encoded Floats.  Sort values are Float and
            lower values are at the front. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.CUSTOM">
            <summary>Sort using a custom Comparator.  Sort values are any Comparable and
            sorting is done according to natural order. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.FIELD_SCORE">
            <summary>Represents sorting by document score (relevancy). </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.FIELD_DOC">
            <summary>Represents sorting by document number (index order). </summary>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String)">
            <summary>Creates a sort by terms in the given Field where the type of term value
            is determined dynamically ({@link #AUTO AUTO}).
            </summary>
            <param name="Field">Name of Field to sort by, cannot be <code>null</code>.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,System.Boolean)">
            <summary>Creates a sort, possibly in reverse, by terms in the given Field where
            the type of term value is determined dynamically ({@link #AUTO AUTO}).
            </summary>
            <param name="Field">Name of Field to sort by, cannot be <code>null</code>.
            </param>
            <param name="reverse">True if natural order should be reversed.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,System.Int32)">
            <summary>Creates a sort by terms in the given Field with the type of term
            values explicitly given.
            </summary>
            <param name="Field"> Name of Field to sort by.  Can be <code>null</code> if
            <code>type</code> is SCORE or DOC.
            </param>
            <param name="type">  Type of values in the terms.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,System.Int32,System.Boolean)">
            <summary>Creates a sort, possibly in reverse, by terms in the given Field with the
            type of term values explicitly given.
            </summary>
            <param name="Field"> Name of Field to sort by.  Can be <code>null</code> if
            <code>type</code> is SCORE or DOC.
            </param>
            <param name="type">  Type of values in the terms.
            </param>
            <param name="reverse">True if natural order should be reversed.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,System.Globalization.CultureInfo)">
            <summary>Creates a sort by terms in the given Field sorted
            according to the given locale.
            </summary>
            <param name="Field"> Name of Field to sort by, cannot be <code>null</code>.
            </param>
            <param name="locale">Locale of values in the Field.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,System.Globalization.CultureInfo,System.Boolean)">
            <summary>Creates a sort, possibly in reverse, by terms in the given Field sorted
            according to the given locale.
            </summary>
            <param name="Field"> Name of Field to sort by, cannot be <code>null</code>.
            </param>
            <param name="locale">Locale of values in the Field.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,Lucene.Net.Search.SortComparatorSource)">
            <summary>Creates a sort with a custom comparison function.</summary>
            <param name="Field">Name of Field to sort by; cannot be <code>null</code>.
            </param>
            <param name="comparator">Returns a comparator for sorting hits.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,Lucene.Net.Search.SortComparatorSource,System.Boolean)">
            <summary>Creates a sort, possibly in reverse, with a custom comparison function.</summary>
            <param name="Field">Name of Field to sort by; cannot be <code>null</code>.
            </param>
            <param name="comparator">Returns a comparator for sorting hits.
            </param>
            <param name="reverse">True if natural order should be reversed.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.GetField">
            <summary>Returns the name of the Field.  Could return <code>null</code>
            if the sort is by SCORE or DOC.
            </summary>
            <returns> Name of Field, possibly <code>null</code>.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.SortField.GetType">
            <summary>Returns the type of contents in the Field.</summary>
            <returns> One of the constants SCORE, DOC, AUTO, STRING, INT or FLOAT.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.SortField.GetLocale">
            <summary>Returns the Locale by which term values are interpreted.
            May return <code>null</code> if no Locale was specified.
            </summary>
            <returns> Locale, or <code>null</code>.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.SortField.GetReverse">
            <summary>Returns whether the sort should be reversed.</summary>
            <returns>  True if natural order should be reversed.
            </returns>
        </member>
        <member name="T:Lucene.Net.Search.TermQuery">
            <summary>A Query that matches documents containing a term.
            This may be combined with other terms with a {@link BooleanQuery}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>Constructs a query for the term <code>t</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.GetTerm">
            <summary>Returns the term of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <member name="T:Lucene.Net.Search.TopDocs">
            <summary>Expert: Returned by low-level search implementations.</summary>
            <seealso cref="!:Searcher#Search(Query,Filter,int)">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Search.TopDocs.totalHits">
            <summary>Expert: The total number of hits for the query.</summary>
            <seealso cref="!:Hits#Length()">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Search.TopDocs.scoreDocs">
            <summary>Expert: The top hits for the query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocs.#ctor(System.Int32,Lucene.Net.Search.ScoreDoc[])">
            <summary>Expert: Constructs a TopDocs.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.TopFieldDocs" -->
        <member name="F:Lucene.Net.Search.TopFieldDocs.fields">
            <summary>The fields which were used to sort results by. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopFieldDocs.#ctor(System.Int32,Lucene.Net.Search.ScoreDoc[],Lucene.Net.Search.SortField[])">
            <summary>Creates one of these objects.</summary>
            <param name="totalHits"> Total number of hits for the query.
            </param>
            <param name="scoreDocs"> The top hits for the query.
            </param>
            <param name="fields">    The sort criteria used to find the top hits.
            </param>
        </member>
        <member name="T:Lucene.Net.Search.WildcardQuery">
            <summary>Implements the wildcard search query. Supported wildcards are <code>*</code>, which
            matches any character sequence (including the empty one), and <code>?</code>,
            which matches any single character. Note this query can be slow, as it
            needs to iterate over all terms. In order to prevent extremely slow WildcardQueries,
            a Wildcard term must not start with one of the wildcards <code>*</code> or
            <code>?</code>.
            
            </summary>
            <seealso cref="T:Lucene.Net.Search.WildcardTermEnum">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.WildcardTermEnum" -->
        <member name="F:Lucene.Net.Search.WildcardTermEnum.WILDCARD_STRING">
            <summary>*****************************************
            String equality with support for wildcards
            ******************************************
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.WildcardTermEnum.#ctor(Lucene.Net.Index.IndexReader,Lucene.Net.Index.Term)">
            <summary> Creates a new <code>WildcardTermEnum</code>.  Passing in a
            {@link Lucene.Net.Index.Term Term} that does not contain a
            <code>WILDCARD_CHAR</code> will cause an exception to be thrown.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.WildcardTermEnum.WildcardEquals(System.String,System.Int32,System.String,System.Int32)">
            <summary> Determines if a word matches a wildcard pattern.
            <small>Work released by Granta Design Ltd after originally being done on
            company time.</small>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.FSDirectory" -->
        <member name="F:Lucene.Net.Store.FSDirectory.DIRECTORIES">
            <summary>This cache of directories ensures that there is a unique Directory
            instance per path, so that synchronization on the Directory can be used to
            synchronize access between readers and writers.
            
            This should be a WeakHashMap, so that entries can be GC'd, but that would
            require Java 1.2.  Instead we use refcounts...
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.FSDirectory.LOCK_DIR">
            <summary> Directory specified by <code>Lucene.Net.lockdir</code>
            or <code>java.io.tmpdir</code> system property
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.FSDirectory.buffer">
            <summary>A buffer optionally used in renameTo method </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.FSDirectory.GetDirectory(System.String,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.FSDirectory.GetDirectory(System.IO.FileInfo,System.Boolean)" -->
        <member name="M:Lucene.Net.Store.FSDirectory.List">
            <summary>Returns an array of strings, one for each file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FileExists(System.String)">
            <summary>Returns true iff a file with the given name exists. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FileModified(System.String)">
            <summary>Returns the time the named file was last modified. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FileModified(System.IO.FileInfo,System.String)">
            <summary>Returns the time the named file was last modified. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.TouchFile(System.String)">
            <summary>Set the modified time of an existing file to now. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FileLength(System.String)">
            <summary>Returns the length in bytes of a file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.DeleteFile(System.String)">
            <summary>Removes an existing file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.RenameFile(System.String,System.String)">
            <summary>Renames an existing file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.CreateFile(System.String)">
            <summary>Creates a new, empty file in the directory with the given name.
            Returns a stream writing this file. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.OpenFile(System.String)">
            <summary>Returns a stream reading an existing file. </summary>
        </member>
        <member name="F:Lucene.Net.Store.FSDirectory.HEX_DIGITS">
            <summary> So we can do some byte-to-hexchar conversion below</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.FSDirectory.MakeLock(System.String)" -->
        <member name="M:Lucene.Net.Store.FSDirectory.Close">
            <summary>Closes the store to future operations. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.ToString">
            <summary>For debug output. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSInputStream.ReadInternal(System.Byte[],System.Int32,System.Int32)">
            <summary>InputStream methods </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSInputStream.SeekInternal(System.Int64)">
            <summary>Random-access methods </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSInputStream.IsFDValid">
            <summary>Method used for testing. Returns true if the underlying
            file descriptor is valid.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.OutputStream">
            <summary>Abstract class for output to a file in a Directory.  A random-access output
            stream.  Used for all Lucene index output operations.
            </summary>
            <seealso cref="T:Lucene.Net.Store.Directory">
            </seealso>
            <seealso cref="T:Lucene.Net.Store.InputStream">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.OutputStream.WriteByte(System.Byte)">
            <summary>Writes a single byte.</summary>
            <seealso cref="!:InputStream#ReadByte()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.OutputStream.WriteBytes(System.Byte[],System.Int32)">
            <summary>Writes an array of bytes.</summary>
            <param name="b">the bytes to write
            </param>
            <param name="length">the number of bytes to write
            </param>
            <seealso cref="!:InputStream#ReadBytes(byte[],int,int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.OutputStream.WriteInt(System.Int32)">
            <summary>Writes an int as four bytes.</summary>
            <seealso cref="!:InputStream#ReadInt()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.OutputStream.WriteVInt(System.Int32)">
            <summary>Writes an int in a variable-length format.  Writes between one and
            five bytes.  Smaller values take fewer bytes.  Negative numbers are not
            supported.
            </summary>
            <seealso cref="!:InputStream#ReadVInt()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.OutputStream.WriteLong(System.Int64)">
            <summary>Writes a long as eight bytes.</summary>
            <seealso cref="!:InputStream#ReadLong()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.OutputStream.WriteVLong(System.Int64)">
            <summary>Writes an long in a variable-length format.  Writes between one and five
            bytes.  Smaller values take fewer bytes.  Negative numbers are not
            supported.
            </summary>
            <seealso cref="!:InputStream#ReadVLong()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.OutputStream.WriteString(System.String)">
            <summary>Writes a string.</summary>
            <seealso cref="!:InputStream#ReadString()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.OutputStream.WriteChars(System.String,System.Int32,System.Int32)">
            <summary>Writes a sequence of UTF-8 encoded characters from a string.</summary>
            <param name="s">the source of the characters
            </param>
            <param name="start">the first character in the sequence
            </param>
            <param name="length">the number of characters in the sequence
            </param>
            <seealso cref="!:InputStream#ReadChars(char[],int,int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.OutputStream.Flush">
            <summary>Forces any buffered output to be written. </summary>
        </member>
        <member name="M:Lucene.Net.Store.OutputStream.FlushBuffer(System.Byte[],System.Int32)">
            <summary>Expert: implements buffer write.  Writes bytes at the current position in
            the output.
            </summary>
            <param name="b">the bytes to write
            </param>
            <param name="len">the number of bytes to write
            </param>
        </member>
        <member name="M:Lucene.Net.Store.OutputStream.Close">
            <summary>Closes this stream to further operations. </summary>
        </member>
        <member name="M:Lucene.Net.Store.OutputStream.GetFilePointer">
            <summary>Returns the current position in this file, where the next write will
            occur.
            </summary>
            <seealso cref="!:#Seek(long)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.OutputStream.Seek(System.Int64)">
            <summary>Sets current position in this file, where the next write will occur.</summary>
            <seealso cref="!:#GetFilePointer()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.OutputStream.Length">
            <summary>The number of bytes in the file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSOutputStream.FlushBuffer(System.Byte[],System.Int32)">
            <summary>output methods: </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSOutputStream.Seek(System.Int64)">
            <summary>Random-access methods </summary>
        </member>
        <member name="T:Lucene.Net.Store.RAMDirectory">
            <summary> A memory-resident {@link Directory} implementation.
            
            </summary>
            <version>  $Id: RAMDirectory.java,v 1.15 2004/05/09 12:41:47 ehatcher Exp $
            </version>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.#ctor">
            <summary>Constructs an empty {@link Directory}. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.RAMDirectory.#ctor(Lucene.Net.Store.Directory)" -->
        <member name="M:Lucene.Net.Store.RAMDirectory.#ctor(System.IO.FileInfo)">
            <summary> Creates a new <code>RAMDirectory</code> instance from the {@link FSDirectory}.
            
            </summary>
            <param name="dir">a <code>File</code> specifying the index directory
            </param>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.#ctor(System.String)">
            <summary> Creates a new <code>RAMDirectory</code> instance from the {@link FSDirectory}.
            
            </summary>
            <param name="dir">a <code>String</code> specifying the full index directory path
            </param>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.List">
            <summary>Returns an array of strings, one for each file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.FileExists(System.String)">
            <summary>Returns true iff the named file exists in this directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.FileModified(System.String)">
            <summary>Returns the time the named file was last modified. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.TouchFile(System.String)">
            <summary>Set the modified time of an existing file to now. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.FileLength(System.String)">
            <summary>Returns the length in bytes of a file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.DeleteFile(System.String)">
            <summary>Removes an existing file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.RenameFile(System.String,System.String)">
            <summary>Removes an existing file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.CreateFile(System.String)">
            <summary>Creates a new, empty file in the directory with the given name.
            Returns a stream writing this file. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.OpenFile(System.String)">
            <summary>Returns a stream reading an existing file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.MakeLock(System.String)">
            <summary>Construct a {@link Lock}.</summary>
            <param name="name">the name of the lock file
            </param>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.Close">
            <summary>Closes the store to future operations. </summary>
        </member>
        <member name="T:Lucene.Net.Store.RAMInputStream">
            <summary> A memory-resident {@link InputStream} implementation.
            
            </summary>
            <version>  $Id: RAMInputStream.java,v 1.2 2004/03/29 22:48:05 cutting Exp $
            </version>
        </member>
        <member name="T:Lucene.Net.Store.RAMOutputStream">
            <summary> A memory-resident {@link OutputStream} implementation.
            
            </summary>
            <version>  $Id: RAMOutputStream.java,v 1.2 2004/03/29 22:48:05 cutting Exp $
            </version>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.#ctor">
            <summary>Construct an empty output buffer. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.WriteTo(Lucene.Net.Store.OutputStream)">
            <summary>Copy the current contents of this buffer to the named output. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.Leset">
            <summary>Resets this to an empty buffer. </summary>
        </member>
        <member name="T:Lucene.Net.Util.BitVector">
            <summary>Optimized implementation of a vector of bits.  This is more-or-less like
            java.util.BitSet, but also includes the following:
            <ul>
            <li>a count() method, which efficiently computes the number of one bits;</li>
            <li>optimized read from and write to disk;</li>
            <li>inlinable get() method;</li>
            </ul>
            </summary>
            <author>  Doug Cutting
            </author>
            <version>  $Id: BitVector.java,v 1.4 2004/03/29 22:48:05 cutting Exp $
            </version>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.#ctor(System.Int32)">
            <summary>Constructs a vector capable of holding <code>n</code> bits. </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.Set(System.Int32)">
            <summary>Sets the value of <code>bit</code> to one. </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.Clear(System.Int32)">
            <summary>Sets the value of <code>bit</code> to zero. </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.Get(System.Int32)">
            <summary>Returns <code>true</code> if <code>bit</code> is one and
            <code>false</code> if it is zero. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.Size">
            <summary>Returns the number of bits in this vector.  This is also one greater than
            the number of the largest valid bit number. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.Count">
            <summary>Returns the total number of one bits in this vector.  This is efficiently
            computed and cached, so that, if the vector is not changed, no
            recomputation is done for repeated calls. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.Write(Lucene.Net.Store.Directory,System.String)">
            <summary>Writes this vector to the file <code>name</code> in Directory
            <code>d</code>, in a format that can be read by the constructor {@link
            #BitVector(Directory, String)}.  
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.#ctor(Lucene.Net.Store.Directory,System.String)">
            <summary>Constructs a bit vector from the file <code>name</code> in Directory
            <code>d</code>, as written by the {@link #write} method.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Constants">
            <summary> Some useful constants.
            
            </summary>
            <author>   Doug Cutting
            </author>
            <version>  $Id: Constants.java,v 1.3 2004/03/29 22:48:05 cutting Exp $
            
            </version>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Util.Constants.JAVA_VERSION" -->
        <member name="F:Lucene.Net.Util.Constants.JAVA_1_1">
            <summary>True iff this is Java version 1.1. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.JAVA_1_2">
            <summary>True iff this is Java version 1.2. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.JAVA_1_3">
            <summary>True iff this is Java version 1.3. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Util.Constants.OS_NAME" -->
        <member name="F:Lucene.Net.Util.Constants.LINUX">
            <summary>True iff running on Linux. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.WINDOWS">
            <summary>True iff running on Windows. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.SUN_OS">
            <summary>True iff running on SunOS. </summary>
        </member>
        <member name="T:Lucene.Net.Util.StringHelper">
            <summary> Methods for manipulating strings.
            
            $Id: StringHelper.java,v 1.2 2004/03/25 13:39:59 otis Exp $
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.StringHelper.StringDifference(System.String,System.String)">
            <summary> Compares two strings, character by character, and returns the
            first position where the two strings differ from one another.
            
            </summary>
            <param name="s1">The first string to compare
            </param>
            <param name="s2">The second string to compare
            </param>
            <returns> The first position where the two strings differ.
            </returns>
        </member>
    </members>
</doc>
