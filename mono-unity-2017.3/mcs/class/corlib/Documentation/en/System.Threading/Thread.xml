<Type Name="Thread" FullName="System.Threading.Thread" FullNameSP="System_Threading_Thread" Maintainer="ecma">
  <TypeSignature Language="ILASM" Value=".class public sealed Thread extends System.Object" />
  <TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <MemberOfLibrary>BCL</MemberOfLibrary>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 ]</AssemblyPublicKey>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadingSafetyStatement>All public static members of this type are safe for multithreaded operations. No instance members are guaranteed to be thread safe.</ThreadingSafetyStatement>
  <Base>
    <BaseTypeName>System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <para> Represents a sequential
      thread of execution. </para>
    </summary>
    <remarks>
      <para> A process can create
      and execute one or more threads to execute a portion of the program
      code associated with the process. A <see cref="T:System.Threading.ThreadStart" /> delegate is used to specify
      the program code
      executed by a thread.</para>
      <para>Some operating systems might
      not utilize the concepts of threads or preemptive scheduling. Also, the concept
      of "thread priority" might not exist at all or its meaning might vary, depending on
      the underlying operating system. Implementers of the <see cref="T:System.Threading.Thread" />
      
      type are required to describe their threading policies,
      including what thread priority means, how many threading priority
      levels exist, and
      whether scheduling is preemptive.</para>
      <para> For the duration of its existence, a thread is always in one
      or more of the states defined by <see cref="T:System.Threading.ThreadState" />. A scheduling priority level, as defined
      by <see cref="T:System.Threading.ThreadPriority" /> , can be requested for a thread, but it might
      not be honored
      by the operating system.</para>
      <para>If an unhandled exception is thrown in the code executed by a thread created
      by an application, a <see cref="F:System.AppDomain.UnhandledException" /> event is raised (<see cref="P:System.UnhandledExceptionEventArgs.IsTerminating" /> is set to <see langword="false" />), and the thread
      is terminated; the current process is not terminated.</para>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberType>Constructor</MemberType>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(class System.Threading.ThreadStart start)" />
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">A <see cref="T:System.Threading.ThreadStart" /> delegate that references the methods to be invoked when the new thread begins executing. </param>
        <summary>
          <para> Constructs and initializes a new instance of the <see cref="T:System.Threading.Thread" />
class.</para>
        </summary>
        <remarks>
          <para>
            <SPAN>
              <block subset="none" type="note">To schedule the thread for execution, call <see cref="M:System.Threading.Thread.Start" />.</block>
            </SPAN>
          </para>
          <para>
            <SPAN>Until <see cref="M:System.Threading.Thread.Start" /> is called, the thread's state includes <see cref="F:System.Threading.ThreadState.Unstarted" />.</SPAN>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start " />is <see langword="null" /> . </exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberType>Constructor</MemberType>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">To be added.</param>
        <param name="maxStackSize">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberType>Constructor</MemberType>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">To be added.</param>
        <param name="maxStackSize">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void Abort()" />
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on
   which it is invoked to begin the process of terminating the thread. In all but
   the most extraordinary situations, calling this method will terminate
   the thread.
   </para>
        </summary>
        <remarks>
          <para> When this method is invoked on a thread, the system
      throws a <see cref="T:System.Threading.ThreadAbortException" /> in the
      thread to abort it. Invoking <see cref="M:System.Threading.Thread.Abort(System.Object)" /> on a thread is similar
      to arranging for the target thread to throw a <see cref="T:System.Threading.ThreadAbortException" />. Because, unlike other
      exceptions, a <see cref="T:System.Threading.ThreadAbortException" /> is sent to another thread, the exception might
      be delayed. A <see cref="T:System.Threading.ThreadAbortException" /> is required to be delayed if and while the
      target thread is executing any of the following:
      </para>
          <list type="bullet">
            <item>
              <term>
         
         unmanaged code</term>
            </item>
            <item>
              <term>
         
         a catch handler</term>
            </item>
            <item>
              <term>
         
         a finally clause</term>
            </item>
            <item>
              <term>
         
         a filter clause</term>
            </item>
            <item>
              <term>
         
         a type initializer</term>
            </item>
          </list>
          <para>A thread abort proceeds as follows:</para>
          <list type="number">
            <item>
              <term>
                <para> An abort begins at the earliest of the following
         times:</para>
                <para> a. when the thread transitions from unmanaged to managed code execution; </para>
                <para> b. when the thread finishes the outermost currently executing catch handler; </para>
                <para> c. immediately if the thread is running managed code outside of any catch handler, finally clause, filter clause or type initializer </para>
              </term>
            </item>
            <item>
              <term>
                <para> Whenever an outermost catch handler finishes
            execution, the <see cref="T:System.Threading.ThreadAbortException" />
            is rethrown unless the thread being
            aborted has called <see cref="M:System.Threading.Thread.ResetAbort" /> since the call to <see cref="M:System.Threading.Thread.Abort(System.Object)" />.
            </para>
              </term>
            </item>
            <item>
              <term>
                <para> When all finally blocks have been called and the
               thread is about to transition to any unmanaged code which executed before the
               first entry to managed code, <see cref="M:System.Threading.Thread.ResetAbort" />
               is called so that a return to managed code will consider the abort to have been successfully processed.
               </para>
              </term>
            </item>
          </list>
          <para> Unexecuted <see langword="finally" /> blocks
      are executed before the thread is aborted; this includes any finally block that
      is executing when the exception is thrown. The thread is not guaranteed to abort
      immediately, or at all. This situation can occur if a thread does an unbounded
      amount of computation in the finally blocks that are called as part
      of the abort procedure, thereby indefinitely delaying the abort. To ensure a thread has aborted, invoke <see cref="M:System.Threading.Thread.Join" />
      on the thread after calling <see cref="M:System.Threading.Thread.Abort(System.Object)" /> . </para>
          <para> If <see cref="M:System.Threading.Thread.Abort(System.Object)" /> is called on a thread that has not been
   started, the thread aborts when <see cref="M:System.Threading.Thread.Start" /> is called. If the target thread is blocked or sleeping in managed code and is not inside any of the code blocks that are required to delay an abort, the thread is resumed and immediately aborted.</para>
          <para> After <see cref="M:System.Threading.Thread.Abort(System.Object)" />
is invoked on a thread, the state
of the thread includes <see cref="F:System.Threading.ThreadState.AbortRequested" />. After the thread has
terminated as a result of a successful call to <see cref="M:System.Threading.Thread.Abort(System.Object)" />, the state of the thread includes
<see cref="F:System.Threading.ThreadState.Stopped" /> and <see cref="F:System.Threading.ThreadState.Aborted" />
. </para>
          <para>
            <block subset="none" type="note">With sufficient permissions, a
   thread that is the target of a <see cref="M:System.Threading.Thread.Abort(System.Object)" /> can cancel the abort using
   the <see cref="M:System.Threading.Thread.ResetAbort" />
   method. For an example that demonstrates calling the <see cref="M:System.Threading.Thread.ResetAbort" /> method, see <see cref="T:System.Threading.ThreadAbortException" />
   .</block>
          </para>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <SPAN>
            <SPAN>Caller does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /> security permission for the thread to be aborted.</SPAN>
          </SPAN>
        </exception>
        <permission cref="!:System.Security.SecurityPermission">Requires permission to control the thread to be aborted. See <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void Abort(object stateInfo)" />
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="stateInfo">A <see cref="T:System.Object" /> that contains application-specific information<SPAN>, such as state, </SPAN><SPAN>which can be used by the thread being aborted.</SPAN></param>
        <summary>
          <para> Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is
   invoked to begin the process of terminating the thread. In all but the most extraordinary situations, calling this method will terminate
   the thread.
   </para>
        </summary>
        <remarks>
          <para>The object passed as the <paramref name="stateInfo" />
parameter can be obtained by accessing the
<see cref="P:System.Threading.ThreadAbortException.ExceptionState" /> 
property.</para>
          <para>
            <block subset="none" type="note">For details on
   aborting threads, see <see cref="M:System.Threading.Thread.Abort(System.Object)" />
   ().</block>
          </para>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <SPAN>
            <SPAN>Caller does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /> security permission for this thread.</SPAN>
          </SPAN>
        </exception>
        <permission cref="!:System.Security.SecurityPermission">Requires permission to control the thread to be aborted. See <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { set; get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { set; get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { set; get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The thread's current principal.</summary>
        <value>An object implementing <see cref="T:System.Security.Principal.IPrincipal" /> which encapsulates information about the principal which the thread is executing on behalf of.</value>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="ILASM" Value=".property class System.Threading.Thread CurrentThread { public hidebysig static specialname class System.Threading.Thread get_CurrentThread() }" />
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>
            <SPAN>Gets a <see cref="T:System.Threading.Thread" />
instance that represents the currently executing thread.</SPAN>
          </para>
        </summary>
        <value>
          <para> An instance of <see cref="T:System.Threading.Thread" /> representing the current thread.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { set; get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="ILASM" Value=".method family hidebysig virtual void Finalize()" />
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Releases the resources held by this instance.
 </para>
        </summary>
        <remarks>
          <para>
            <block subset="none" type="note">Application code
 does not call this method; it is automatically invoked during garbage
 collection.</block>
          </para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("see CompressedStack class")</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
      </Parameters>
      <Docs>
        <param name="slot">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.AppDomain GetDomain()" />
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Returns an object representing the application domain in
      which the current thread is executing.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.AppDomain" /> object that represents the current application domain.</para>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>RuntimeInfrastructure</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="ILASM" Value=".property bool IsAlive { public hidebysig specialname instance bool get_IsAlive() }" />
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Gets a <see cref="T:System.Boolean" /> value
   indicating the execution status of the current thread.
   </para>
        </summary>
        <value>
          <para>
            <see langword="true " />
if this thread has been started, and has not terminated; otherwise,
<see langword="false" />.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="ILASM" Value=".property bool IsBackground { public hidebysig specialname instance bool get_IsBackground() public hidebysig specialname instance void set_IsBackground(bool value) }" />
      <MemberSignature Language="C#" Value="public bool IsBackground { set; get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Gets or sets a <see cref="T:System.Boolean" />
value indicating whether a thread is a background thread.</para>
        </summary>
        <value>
          <para>
            <see langword="true " />if the thread is or is to become
   a background thread; otherwise, <see langword="false" />.
   </para>
        </value>
        <remarks>
          <para>The default value of this property is <see langword="false" />. The property value can be changed before
   the thread is started and before it terminates.</para>
          <para>
            <block subset="none" type="note">A thread is either
   a background thread or a foreground thread. Background threads are identical to
   foreground threads except for the fact that background threads do not
   prevent a process from terminating. Once all foreground threads belonging to a
   process have terminated, the execution engine ends the process by invoking
<see cref="M:System.Threading.Thread.Abort(System.Object)" /> on any background threads that
   
   are
   still alive. </block>
          </para>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"> The thread has reached the <see cref="F:System.Threading.ThreadState.Stopped" /> state. </exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void Join()" />
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Blocks the calling thread until the thread on which this method
      is invoked terminates.
      </para>
        </summary>
        <remarks>
          <para>
            <block subset="none" type="note">Use this method to
      ensure a thread has terminated. The caller will block indefinitely if the thread
      does not
      terminate.</block>
          </para>
          <para>
            <see cref="M:System.Threading.Thread.Join" /> cannot be invoked on a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</para>
          <para>This method changes the state of the calling thread to include <see cref="F:System.Threading.ThreadState.WaitSleepJoin" />. </para>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state. </exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout)" />
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">A <see cref="T:System.Int32" /> containing the number of milliseconds to wait for the thread to terminate. </param>
        <summary>
          <para> Blocks the calling thread until the thread on which this method is invoked terminates or the specified time elapses.
      </para>
        </summary>
        <returns>
          <para>
            <see langword="true " />if the thread has terminated; <see langword="false " /> if the
   thread has not terminated after <paramref name="millisecondsTimeout" />
   has elapsed.</para>
        </returns>
        <remarks>
          <para>
            <block subset="none" type="note">If <see cref="F:System.Threading.Timeout.Infinite" qualify="true" /> is specified for <paramref name="millisecondsTimeout" />, this method
   behaves identically to <see langword="Join" />
   (), except for the return value.</block>
          </para>
          <para>
            <see langword="Join" /> cannot be invoked on a thread
that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</para>
          <para>This method changes the state of the calling thread to include <see cref="F:System.Threading.ThreadState.WaitSleepJoin" />.</para>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value of <paramref name="millisecondsTimeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> .</exception>
        <exception cref="T:System.Threading.ThreadStateException">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state. </exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout)" />
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> set to the amount of time to wait for the thread to terminate. Specify <see cref="F:System.Threading.Timeout.Infinite" qualify="true" /> milliseconds to wait indefinitely. </param>
        <summary>
          <para> Blocks the calling thread until the thread on which this method is invoked terminates or the specified time
      elapses.
      </para>
        </summary>
        <returns>
          <para>
            <see langword="true " />if the thread has terminated;
<see langword="false " /> if the thread has not terminated after the amount 
   of time specified by <paramref name="timeout" />
   has elapsed.</para>
        </returns>
        <remarks>
          <para>This method converts <paramref name="timeout " />to milliseconds,
   tests the validity of the converted value, and calls <see cref="M:System.Threading.Thread.Join" />(<see cref="T:System.Int32" />).</para>
          <para>
            <block subset="none" type="note">If <see cref="F:System.Threading.Timeout.Infinite" qualify="true" /> milliseconds is specified for
<paramref name="timeout" />, this method 
behaves identically to <see langword="Join" /> (),
except for the return value.</block>
          </para>
          <para>
            <see langword="Join" /> cannot be invoked on a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</para>
          <para>This method changes the state of the current thread to include <see cref="F:System.Threading.ThreadState.WaitSleepJoin" />.</para>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" qualify="true" /> milliseconds.</exception>
        <exception cref="T:System.Threading.ThreadStateException">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state. </exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Guarantees that all subsequent loads or stores from the current thread will not access memory until after all previous loads and stores from the current thread have completed, as observed from this or other threads.</para>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="ILASM" Value=".property string Name { public hidebysig specialname instance string get_Name() public hidebysig specialname instance void set_Name(string value) }" />
      <MemberSignature Language="C#" Value="public string Name { set; get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Gets or
      sets the name of
      the thread.
      </para>
        </summary>
        <value>
          <para>A <see cref="T:System.String" /> containing the
   name of the thread, or <see langword="null" /> if no name
   was set.</para>
        </value>
        <remarks>
          <para>This property is write-once. Once this property has been 
      set to a non-null value, attempts to set this property to a new value cause an exception.</para>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A set operation was requested, and the <see langword="Name" /> property has already been set.</exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="ILASM" Value=".property valuetype System.Threading.ThreadPriority Priority { public hidebysig specialname instance valuetype System.Threading.ThreadPriority get_Priority() public hidebysig specialname instance void set_Priority(valuetype System.Threading.ThreadPriority value) }" />
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { set; get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>
            <SPAN>
      Gets or sets a value indicating the scheduling priority of a thread.</SPAN>
          </para>
        </summary>
        <value>
          <para> A <see cref="T:System.Threading.ThreadPriority" /> value.
   </para>
        </value>
        <remarks>
          <para>A thread can be assigned any one of the following
      priority values:</para>
          <list type="bullet">
            <item>
              <term>
                <see cref="F:System.Threading.ThreadPriority.Highest" />
              </term>
            </item>
            <item>
              <term>
                <see cref="F:System.Threading.ThreadPriority.AboveNormal" />
              </term>
            </item>
            <item>
              <term>
                <see cref="F:System.Threading.ThreadPriority.Normal" />
              </term>
            </item>
            <item>
              <term>
                <see cref="F:System.Threading.ThreadPriority.BelowNormal" />
              </term>
            </item>
            <item>
              <term>
                <see cref="F:System.Threading.ThreadPriority.Lowest" />
              </term>
            </item>
          </list>
          <para> The default value is <see cref="F:System.Threading.ThreadPriority.Normal" />.</para>
          <para>Operating systems are not required to honor the priority
   of a thread.</para>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"> The thread is in the <see cref="F:System.Threading.ThreadState.Stopped" /> state.</exception>
        <exception cref="T:System.ArgumentException">The value specified for a set operation is not a valid <see cref="T:System.Threading.ThreadPriority" /> value. </exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void ResetAbort()" />
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Cancels a <see cref="M:System.Threading.Thread.Abort(System.Object)" /> requested for the current thread.</para>
        </summary>
        <remarks>
          <para> This method cannot be called by untrusted code.
      </para>
          <para> When a call is made to <see cref="M:System.Threading.Thread.Abort(System.Object)" />
to destroy a thread, the system throws a <see cref="T:System.Threading.ThreadAbortException" />. <see cref="T:System.Threading.ThreadAbortException" /> is a special
exception that can be caught by application code, but is rethrown at the end of
the catch block unless <see langword="ResetAbort " />is called.
<see langword="ResetAbort " />cancels the request to 
abort, and prevents the <see langword=" ThreadAbortException" />
from terminating the thread.</para>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">
          <see cref="M:System.Threading.Thread.Abort(System.Object)" /> was not invoked on the current thread.</exception>
        <exception cref="T:System.Security.SecurityException">
          <SPAN>Caller does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /> security permission for the current thread.</SPAN>
        </exception>
        <permission cref="!:System.Security.SecurityPermission">Requires permission to control the current thread. See <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <example>
          <para>For an example that demonstrates calling 
      this method, see <see cref="T:System.Threading.ThreadAbortException" /> .</para>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("")</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" />
      </Parameters>
      <Docs>
        <param name="stack">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("see CompressedStack class")</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="slot">To be added.</param>
        <param name="data">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Sleep(int32 millisecondsTimeout)" />
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">A <see cref="T:System.Int32" /> containing the number of milliseconds for which the thread is blocked. Specify zero to indicate that this thread should be suspended temporarily to allow other waiting threads to execute. Specify <see cref="F:System.Threading.Timeout.Infinite" qualify="true" /> to block the thread indefinitely. </param>
        <summary>
          <para> Blocks the current thread for the specified number of milliseconds.
      </para>
        </summary>
        <remarks>
          <para>The thread will not be scheduled for execution by
      the operating system for the amount of time specified. This method changes the
      state of the thread to include <see cref="F:System.Threading.ThreadState.WaitSleepJoin" />.</para>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value of <paramref name="millisecondsTimeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" qualify="true" /> .</exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Sleep(valuetype System.TimeSpan timeout)" />
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> set to the amount of time for which the current thread will be blocked. Specify zero to indicate that this thread should be suspended temporarily to allow other waiting threads to execute. Specify <see cref="F:System.Threading.Timeout.Infinite" qualify="true" /> milliseconds to suspend the thread indefinitely. </param>
        <summary>
          <para> Blocks the current thread for a specified time.
      </para>
        </summary>
        <remarks>
          <para>This method converts <paramref name="timeout " />to milliseconds,
   tests the validity of the converted value, and calls <see cref="M:System.Threading.Thread.Sleep(System.Int32)" />(<see cref="T:System.Int32" />).</para>
          <para>The thread will not be scheduled for execution by the operating system
   for the amount of time specified. This method changes the state of the thread to
   include <see cref="F:System.Threading.ThreadState.WaitSleepJoin" />.</para>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" qualify="true" /> milliseconds.</exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="iterations">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void Start()" />
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Causes the operating system to consider the thread ready 
      to be scheduled for execution.</para>
        </summary>
        <remarks>
          <para>Calling <see cref="M:System.Threading.Thread.Start" /> removes the <see cref="F:System.Threading.ThreadState.Unstarted" /> state from the
<see cref="P:System.Threading.Thread.ThreadState" /> of the thread.</para>
          <para> Once a thread is started,
   the operating system can schedule it for execution. When the thread begins executing, the <see cref="T:System.Threading.ThreadStart" />
   delegate supplied to the constructor for the thread invokes its
   methods.</para>
          <para> Once the thread terminates, it cannot be restarted with another call to <see cref="M:System.Threading.Thread.Start" />.</para>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory available to start the thread.</exception>
        <exception cref="T:System.NullReferenceException">This method was invoked on a <see langword="null" /> thread reference.</exception>
        <exception cref="T:System.Threading.ThreadStateException">The thread has already been started. </exception>
        <example>
          <para>The following example demonstrates creating a thread and starting it.</para>
          <code lang="C#">using System;
using System.Threading;
public class ThreadWork {
  public static void DoWork() {
    for (int i = 0; i&lt;3;i++) {
         Console.WriteLine ("Working thread ...");
         Thread.Sleep(100);
    }
  }
}
class ThreadTest{
  public static void Main() {
    ThreadStart myThreadDelegate = new ThreadStart(ThreadWork.DoWork);
    Thread myThread = new Thread(myThreadDelegate);
    myThread.Start();
    for (int i = 0; i&lt;3; i++) {
        Console.WriteLine("In main.");
        Thread.Sleep(100);
    }
  }
}
   </code>
          <para>One possible set of output is</para>
          <c>
            <para>In main. </para>
            <para>Working thread ... </para>
            <para>In main. </para>
            <para>Working thread ... </para>
            <para>In main. </para>
            <para>Working thread ... </para>
          </c>
          <para> Note that the sequence of the output statements is not guaranteed to be identical across systems. </para>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("")</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">To be added.</param>
        <param name="rgszNames">To be added.</param>
        <param name="cNames">To be added.</param>
        <param name="lcid">To be added.</param>
        <param name="rgDispId">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">To be added.</param>
        <param name="lcid">To be added.</param>
        <param name="ppTInfo">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">To be added.</param>
        <param name="riid">To be added.</param>
        <param name="lcid">To be added.</param>
        <param name="wFlags">To be added.</param>
        <param name="pDispParams">To be added.</param>
        <param name="pVarResult">To be added.</param>
        <param name="pExcepInfo">To be added.</param>
        <param name="puArgErr">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="ILASM" Value=".property valuetype System.Threading.ThreadState ThreadState { public hidebysig specialname instance valuetype System.Threading.ThreadState get_ThreadState() }" />
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>
            <SPAN>Gets a value containing the
      states of the current thread.</SPAN>
          </para>
        </summary>
        <value>
          <para> A combination of one or more <see cref="T:System.Threading.ThreadState" /> values, which indicate
   the state of the current thread.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>A thread is running if the value returned by this property does not include <see cref="F:System.Threading.ThreadState.Unstarted" /> and does not include <see cref="F:System.Threading.ThreadState.Stopped" />.</para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static byte VolatileRead (class System.Byte&amp; address)" />
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Byte" /> that specifies the address in memory from which to read.</param>
        <summary>
          <para>Performs a volatile read from the specified address.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Byte" /> containing the value at the specified address after any pending writes.</para>
        </returns>
        <remarks>
          <para>The value at the given address is atomically loaded with acquire semantics, meaning that the read is guaranteed to occur prior to any references to memory that occur after the execution of this method in the current thread. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileWrite" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the load CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static float64 VolatileRead (class System.Double&amp; address)" />
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Double" /> that specifies the address in memory from which to read.</param>
        <summary>
          <para>Performs a volatile read from the specified address.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Double" /> containing the value at the specified address after any pending writes.</para>
        </returns>
        <remarks>
          <para>The value at the given address is atomically loaded with acquire semantics, meaning that the read is guaranteed to occur prior to any references to memory that occur after the execution of this method in the current thread. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileWrite" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the load CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int16 VolatileRead (class System.Int16&amp; address)" />
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Int16" /> that specifies the address in memory from which to read.</param>
        <summary>
          <para>Performs a volatile read from the specified address.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int16" /> containing the value at the specified address after any pending writes.</para>
        </returns>
        <remarks>
          <para>The value at the given address is atomically loaded with acquire semantics, meaning that the read is guaranteed to occur prior to any references to memory that occur after the execution of this method in the current thread. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileWrite" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the load CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 VolatileRead (class System.Int32&amp; address)" />
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Int32" /> that specifies the address in memory from which to read.</param>
        <summary>
          <para>Performs a volatile read from the specified address.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int32" /> containing the value at the specified address after any pending writes.</para>
        </returns>
        <remarks>
          <para>The value at the given address is atomically loaded with acquire semantics, meaning that the read is guaranteed to occur prior to any references to memory that occur after the execution of this method in the current thread. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileWrite" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the load CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int64 VolatileRead (class System.Int64&amp; address)" />
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Int64" /> that specifies the address in memory from which to read.</param>
        <summary>
          <para>Performs a volatile read from the specified address.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int64" /> containing the value at the specified address after any pending writes.</para>
        </returns>
        <remarks>
          <para>The value at the given address is atomically loaded with acquire semantics, meaning that the read is guaranteed to occur prior to any references to memory that occur after the execution of this method in the current thread. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileWrite" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the load CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static intptr VolatileRead (class System.IntPtr&amp; address)" />
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.IntPtr" /> that specifies the address in memory from which to read.</param>
        <summary>
          <para>Performs a volatile read from the specified address.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.IntPtr" /> containing the value at the specified address after any pending writes.</para>
        </returns>
        <remarks>
          <para>The value at the given address is atomically loaded with acquire semantics, meaning that the read is guaranteed to occur prior to any references to memory that occur after the execution of this method in the current thread. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileWrite" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the load CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>RuntimeInfrastructure</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static object VolatileRead (class System.Object&amp; address)" />
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Object" /> that specifies the address in memory from which to read.</param>
        <summary>
          <para>Performs a volatile read from the specified address.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Object" /> containing the value at the specified address after any pending writes.</para>
        </returns>
        <remarks>
          <para>The value at the given address is atomically loaded with acquire semantics, meaning that the read is guaranteed to occur prior to any references to memory that occur after the execution of this method in the current thread. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileWrite" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the load CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static sbyte VolatileRead (class System.Sbyte&amp; address)" />
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.SByte" /> that specifies the address in memory from which to read.</param>
        <summary>
          <para>Performs a volatile read from the specified address.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.SByte" /> containing the value at the specified address after any pending writes.</para>
        </returns>
        <remarks>
          <para>The value at the given address is atomically loaded with acquire semantics, meaning that the read is guaranteed to occur prior to any references to memory that occur after the execution of this method in the current thread. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileWrite" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the load CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static float32 VolatileRead (class System.Single&amp; address)" />
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Single" /> that specifies the address in memory from which to read.</param>
        <summary>
          <para>Performs a volatile read from the specified address.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Single" /> containing the value at the specified address after any pending writes.</para>
        </returns>
        <remarks>
          <para>The value at the given address is atomically loaded with acquire semantics, meaning that the read is guaranteed to occur prior to any references to memory that occur after the execution of this method in the current thread. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileWrite" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the load CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static uint16 VolatileRead (class System.UInt16&amp; address)" />
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.UInt16" /> that specifies the address in memory from which to read.</param>
        <summary>
          <para>Performs a volatile read from the specified address.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.UInt16" /> containing the value at the specified address after any pending writes.</para>
        </returns>
        <remarks>
          <para>The value at the given address is atomically loaded with acquire semantics, meaning that the read is guaranteed to occur prior to any references to memory that occur after the execution of this method in the current thread. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileWrite" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the load CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static uint32 VolatileRead (class System.UInt32&amp; address)" />
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.UInt32" /> that specifies the address in memory from which to read.</param>
        <summary>
          <para>Performs a volatile read from the specified address.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.UInt32" /> containing the value at the specified address after any pending writes.</para>
        </returns>
        <remarks>
          <para>The value at the given address is atomically loaded with acquire semantics, meaning that the read is guaranteed to occur prior to any references to memory that occur after the execution of this method in the current thread. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileWrite" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the load CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static uint64 VolatileRead (class System.UInt64&amp; address)" />
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.UInt64" /> that specifies the address in memory from which to read.</param>
        <summary>
          <para>Performs a volatile read from the specified address.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.UInt64" /> containing the value at the specified address after any pending writes.</para>
        </returns>
        <remarks>
          <para>The value at the given address is atomically loaded with acquire semantics, meaning that the read is guaranteed to occur prior to any references to memory that occur after the execution of this method in the current thread. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileWrite" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the load CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.UIntPtr" /> that specifies the address in memory from which to read.</param>
        <summary>
          <para>Performs a volatile read from the specified address.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.UIntPtr" /> containing the value at the specified address after any pending writes.</para>
        </returns>
        <remarks>
          <para>The value at the given address is atomically loaded with acquire semantics, meaning that the read is guaranteed to occur prior to any references to memory that occur after the execution of this method in the current thread. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileWrite" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the load CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void VolatileWrite (class System.Byte&amp; address, byte value)" />
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Byte" /> that specifies the address in memory at which to write.</param>
        <param name="value">A <see cref="T:System.Byte" /> that specifies the value to write.</param>
        <summary>
          <para>Performs a volatile write to the specified address.</para>
        </summary>
        <remarks>
          <para>The value is written atomically to the specified address with release semantics, meaning that the write is guaranteed to happen after any references to memory that occur prior to the execution. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileRead" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the store CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void VolatileWrite (class System.Double&amp; address, float64 value)" />
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Double" /> that specifies the address in memory at which to write.</param>
        <param name="value">A <see cref="T:System.Double" /> that specifies the value to write.</param>
        <summary>
          <para>Performs a volatile write to the specified address.</para>
        </summary>
        <remarks>
          <para>The value is written atomically to the specified address with release semantics, meaning that the write is guaranteed to happen after any references to memory that occur prior to the execution. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileRead" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the store CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void VolatileWrite (class System.Int16&amp; address, int16 value)" />
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Int16" /> that specifies the address in memory at which to write.</param>
        <param name="value">A <see cref="T:System.Int16" /> that specifies the value to write.</param>
        <summary>
          <para>Performs a volatile write to the specified address.</para>
        </summary>
        <remarks>
          <para>The value is written atomically to the specified address with release semantics, meaning that the write is guaranteed to happen after any references to memory that occur prior to the execution. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileRead" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the store CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void VolatileWrite (class System.Int32&amp; address, int32 value)" />
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Int32" /> that specifies the address in memory at which to write.</param>
        <param name="value">A <see cref="T:System.Int32" /> that specifies the value to write.</param>
        <summary>
          <para>Performs a volatile write to the specified address.</para>
        </summary>
        <remarks>
          <para>The value is written atomically to the specified address with release semantics, meaning that the write is guaranteed to happen after any references to memory that occur prior to the execution. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileRead" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the store CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void VolatileWrite (class System.Int64&amp; address, int64 value)" />
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Int64" /> that specifies the address in memory at which to write.</param>
        <param name="value">A <see cref="T:System.Int64" /> that specifies the value to write.</param>
        <summary>
          <para>Performs a volatile write to the specified address.</para>
        </summary>
        <remarks>
          <para>The value is written atomically to the specified address with release semantics, meaning that the write is guaranteed to happen after any references to memory that occur prior to the execution. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileRead" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the store CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void VolatileWrite (class System.IntPtr&amp; address, IntPtr value)" />
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.IntPtr" /> that specifies the address in memory at which to write.</param>
        <param name="value">A <see cref="T:System.IntPtr" /> that specifies the value to write.</param>
        <summary>
          <para>Performs a volatile write to the specified address.</para>
        </summary>
        <remarks>
          <para>The value is written atomically to the specified address with release semantics, meaning that the write is guaranteed to happen after any references to memory that occur prior to the execution. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileRead" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the store CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>RuntimeInfrastructure</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void VolatileWrite (class System.Object&amp; address, object value)" />
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Object" /> that specifies the address in memory at which to write.</param>
        <param name="value">A <see cref="T:System.Object" /> that specifies the value to write.</param>
        <summary>
          <para>Performs a volatile write to the specified address.</para>
        </summary>
        <remarks>
          <para>The value is written atomically to the specified address with release semantics, meaning that the write is guaranteed to happen after any references to memory that occur prior to the execution. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileRead" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the store CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void VolatileWrite (class System.SByte&amp; address, sbyte value)" />
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.SByte" /> that specifies the address in memory at which to write.</param>
        <param name="value">A <see cref="T:System.SByte" /> that specifies the value to write.</param>
        <summary>
          <para>Performs a volatile write to the specified address.</para>
        </summary>
        <remarks>
          <para>The value is written atomically to the specified address with release semantics, meaning that the write is guaranteed to happen after any references to memory that occur prior to the execution. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileRead" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the store CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void VolatileWrite (class System.Single&amp; address, float32 value)" />
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Single" /> that specifies the address in memory at which to write.</param>
        <param name="value">A <see cref="T:System.Single" /> that specifies the value to write.</param>
        <summary>
          <para>Performs a volatile write to the specified address.</para>
        </summary>
        <remarks>
          <para>The value is written atomically to the specified address with release semantics, meaning that the write is guaranteed to happen after any references to memory that occur prior to the execution. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileRead" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the store CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void VolatileWrite (class System.UInt16&amp; address, uint16 value)" />
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.UInt16" /> that specifies the address in memory at which to write.</param>
        <param name="value">A <see cref="T:System.UInt16" /> that specifies the value to write.</param>
        <summary>
          <para>Performs a volatile write to the specified address.</para>
        </summary>
        <remarks>
          <para>The value is written atomically to the specified address with release semantics, meaning that the write is guaranteed to happen after any references to memory that occur prior to the execution. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileRead" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the store CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void VolatileWrite (class System.UInt32&amp; address, uint32 value)" />
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.UInt32" /> that specifies the address in memory at which to write.</param>
        <param name="value">A <see cref="T:System.UInt32" /> that specifies the value to write.</param>
        <summary>
          <para>Performs a volatile write to the specified address.</para>
        </summary>
        <remarks>
          <para>The value is written atomically to the specified address with release semantics, meaning that the write is guaranteed to happen after any references to memory that occur prior to the execution. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileRead" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the store CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.UInt64" /> that specifies the address in memory at which to write.</param>
        <param name="value">A <see cref="T:System.UInt64" /> that specifies the value to write.</param>
        <summary>
          <para>Performs a volatile write to the specified address.</para>
        </summary>
        <remarks>
          <para>The value is written atomically to the specified address with release semantics, meaning that the write is guaranteed to happen after any references to memory that occur prior to the execution. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileRead" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the store CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void VolatileWrite (class System.UIntPtr&amp; address, UIntPtr value)" />
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.UIntPtr" /> that specifies the address in memory at which to write.</param>
        <param name="value">A <see cref="T:System.UIntPtr" /> that specifies the value to write.</param>
        <summary>
          <para>Performs a volatile write to the specified address.</para>
        </summary>
        <remarks>
          <para>The value is written atomically to the specified address with release semantics, meaning that the write is guaranteed to happen after any references to memory that occur prior to the execution. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileRead" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the store CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>RuntimeInfrastructure</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
  </Members>
  <TypeExcluded>0</TypeExcluded>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
</Type>
